---
phase: 06-github-integration-analytics
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:

  - src/shared/lib/analytics/github.ts
  - src/shared/lib/analytics/index.ts

autonomous: true

must_haves:
  truths:

```markdown

- "GitHub API calls include rate limit header checking"
- "Rate limit exhaustion is handled gracefully without errors"
- "GitHub user data is cached for 24 hours to minimize API calls"
- "ETag caching prevents redundant API calls"

```yaml

  artifacts:

```yaml

- path: "src/shared/lib/analytics/github.ts"

  provides: "GitHub API client with rate limiting"
  exports: ["enrichUserWithGitHubData", "checkRateLimitStatus"]

```yaml

  key_links:

```yaml

- from: "src/shared/lib/analytics/github.ts"

  to: "<https://api.github.com/user">
  via: "fetch with Authorization header"
  pattern: "fetch.*api\\.github\\.com"

- from: "src/shared/lib/analytics/github.ts"

  to: "x-ratelimit headers"
  via: "response header parsing"
  pattern: "x-ratelimit-remaining"

```html

---

<objective>
Create GitHub API integration with proper rate limit handling for user
enrichment data.

Purpose: Enable fetching additional user data from GitHub (repos, activity
patterns) for brain learning while respecting API rate limits and preventing
service disruptions. This builds on the existing GitHub OAuth integration from
Phase 2.

Output: GitHub API client with ETag caching, rate limit monitoring, exponential
backoff, and graceful degradation when limits are hit.
</objective>

<execution_context>
@/Users/dansidanutz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dansidanutz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-github-integration-analytics/06-RESEARCH.md

# Existing auth setup

@src/shared/lib/auth.ts
@src/shared/lib/dal.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GitHub API client with rate limit handling</name>
  <files>src/shared/lib/analytics/github.ts</files>
  <action>
Create `src/shared/lib/analytics/github.ts` with comprehensive rate limit
handling:

1. Define types for rate limit info and cached data:

```typescript

import 'server-only'
import { prisma } from '@/shared/lib/db'

interface RateLimitInfo {
  limit: number
  remaining: number
  reset: number  // Unix timestamp
  used: number
}

interface GitHubUserData {
  login: string
  id: number
  avatar_url: string
  html_url: string
  name: string | null
  company: string | null
  blog: string | null
  location: string | null
  bio: string | null
  public_repos: number
  public_gists: number
  followers: number
  following: number
  created_at: string
}

interface CacheEntry {
  data: GitHubUserData
  etag: string
  cachedAt: number
}

// In-memory cache for rate limit efficiency
// Production would use Redis, but Map is fine for validation project
const userCache = new Map<string, CacheEntry>()
const CACHE_TTL = 24 * 60 * 60 * 1000  // 24 hours per research

```python

2. Parse rate limit headers from response:

```typescript

/**

 * Extract rate limit info from GitHub API response headers.

 */
function parseRateLimitHeaders(response: Response): RateLimitInfo {
  return {

```bash

limit: parseInt(response.headers.get('x-ratelimit-limit') || '5000', 10),
remaining: parseInt(response.headers.get('x-ratelimit-remaining') || '0', 10),
reset: parseInt(response.headers.get('x-ratelimit-reset') || '0', 10),
used: parseInt(response.headers.get('x-ratelimit-used') || '0', 10),

```
  }
}

```yaml

3. Create public rate limit status checker:

```typescript

/**

 * Check current rate limit status for a given access token.
 * Use this before making expensive API operations.

 *

 * @returns Current rate limit info or null if check fails

 */
export async function checkRateLimitStatus(
  accessToken: string
): Promise<RateLimitInfo | null> {
  try {

```javascript

const response = await fetch('<https://api.github.com/rate_limit',> {
  headers: {

```yaml
'Authorization': `Bearer ${accessToken}`,
'Accept': 'application/vnd.github.v3+json',
'X-GitHub-Api-Version': '2022-11-28',

```yaml

  },
  signal: AbortSignal.timeout(5000),
})

if (!response.ok) {
  console.warn('[GitHub] Rate limit check failed:', response.status)
  return null
}

return parseRateLimitHeaders(response)

```text
  } catch (error) {

```

console.error('[GitHub] Rate limit check error:', error)
return null

```yaml
  }
}

```yaml

4. Create main enrichment function with caching:

```typescript

/**

 * Fetch enriched user data from GitHub API with caching and rate limit handling.

 *

 * Features:
 * - 24-hour in-memory cache to minimize API calls
 * - ETag-based conditional requests (304 responses don't count against limit)
 * - Graceful degradation when rate limited
 * - 5-second timeout to prevent hanging

 *

 * @param userId - Internal user ID (for cache key)
 * @param accessToken - GitHub OAuth access token
 * @returns GitHub user data or null if unavailable

 */
export async function enrichUserWithGitHubData(
  userId: string,
  accessToken: string
): Promise<GitHubUserData | null> {
  const now = Date.now()
  const cached = userCache.get(userId)

  // Return cached data if still valid
  if (cached && (now - cached.cachedAt) < CACHE_TTL) {

```text

return cached.data

```text
  }

  try {

```javascript

const response = await fetch('<https://api.github.com/user',> {
  headers: {

```yaml
'Authorization': `Bearer ${accessToken}`,
'Accept': 'application/vnd.github.v3+json',
'X-GitHub-Api-Version': '2022-11-28',
// ETag caching - 304 responses don't count against rate limit
...(cached?.etag ? { 'If-None-Match': cached.etag } : {}),

```

  },
  signal: AbortSignal.timeout(5000),
})

const rateLimit = parseRateLimitHeaders(response)

// Log warning when running low
if (rateLimit.remaining < 100) {
  console.warn(

```yaml
`[GitHub] Rate limit low: ${rateLimit.remaining}/${rateLimit.limit}
remaining. ` +
`Resets at ${new Date(rateLimit.reset * 1000).toISOString()}`

```bash

  )
}

// Handle 304 Not Modified - extend cache TTL
if (response.status === 304 && cached) {
  userCache.set(userId, { ...cached, cachedAt: now })
  return cached.data
}

// Handle rate limiting gracefully
if (response.status === 403 || response.status === 429) {
  const resetTime = new Date(rateLimit.reset * 1000)
  console.error(

```yaml
`[GitHub] Rate limited until ${resetTime.toISOString()}. ` +
`Remaining: ${rateLimit.remaining}`

```

  )
  // Return stale cached data if available, otherwise null
  return cached?.data || null
}

// Handle other errors
if (!response.ok) {
  console.error('[GitHub] API error:', response.status, response.statusText)
  return cached?.data || null
}

// Parse and cache successful response
const data: GitHubUserData = await response.json()
const etag = response.headers.get('etag') || ''

userCache.set(userId, { data, etag, cachedAt: now })

return data

```text
  } catch (error) {

```yaml

console.error('[GitHub] API request failed:', error)
// Graceful degradation - return cached data if available
return cached?.data || null

```text
  }
}

```python

5. Add function to get access token from database:

```typescript

/**

 * Get GitHub access token for a user from their linked account.
 * The token was stored during OAuth sign-in in Phase 2.

 *

 * @param userId - Internal user ID
 * @returns Access token or null if not found

 */
export async function getGitHubAccessToken(
  userId: string
): Promise<string | null> {
  const account = await prisma.account.findFirst({

```yaml

where: {
  userId,
  provider: 'github',
},
select: {
  access_token: true,
},

```bash
  })

  return account?.access_token || null
}

```yaml

6. Add convenience function to enrich user by ID:

```typescript

/**

 * Enrich user with GitHub data using stored access token.
 * Convenience wrapper that handles token retrieval.

 *

 * @param userId - Internal user ID
 * @returns GitHub user data or null if unavailable

 */
export async function enrichUser(
  userId: string
): Promise<GitHubUserData | null> {
  const accessToken = await getGitHubAccessToken(userId)

  if (!accessToken) {

```yaml

console.warn('[GitHub] No access token found for user:', userId)
return null

```
  }

  return enrichUserWithGitHubData(userId, accessToken)
}

```yaml

CRITICAL: Always include timeout with AbortSignal.timeout() to prevent hanging
requests.

AVOID:

- Making API calls without checking/handling rate limits
- Throwing errors on rate limit - always gracefully degrade
- Storing the full API response - only cache what's needed

  </action>
  <verify>

- File compiles without TypeScript errors
- `npm run typecheck` passes
- Functions can be imported from the module

  </verify>
  <done>GitHub API client with rate limiting, ETag caching, and graceful
  degradation</done>
</task>

<task type="auto">
  <name>Task 2: Update barrel export and add GitHub types</name>
  <files>src/shared/lib/analytics/index.ts</files>
  <action>
Update `src/shared/lib/analytics/index.ts` to export GitHub functions:

```typescript

// Event tracking
export { trackEvent, trackEventAsync, trackSessionEvent } from './tracker'
export { AnalyticsEventSchema, type AnalyticsEvent, type EventType } from './types'

// GitHub API integration
export {
  enrichUserWithGitHubData,
  enrichUser,
  checkRateLimitStatus,
  getGitHubAccessToken,
} from './github'

```yaml

Note: If Plan 01 hasn't run yet (no tracker.ts), just export the GitHub
functions. The tracker exports will be added by Plan 01.

AVOID: Circular imports - GitHub module should not import from tracker.
  </action>
  <verify>

- File compiles without TypeScript errors
- All exports are accessible via `import { ... } from '@/shared/lib/analytics'`

  </verify>
  <done>Barrel export includes all GitHub functions</done>
</task>

<task type="auto">
  <name>Task 3: Create integration test for rate limit handling</name>
  <files>src/shared/lib/analytics/__tests__/github.test.ts</files>
  <action>
Create a simple test file to verify the GitHub integration works correctly. This
can be run manually or via test runner.

```typescript

/**

 * Manual integration test for GitHub API client.
 * Run with: npx tsx src/shared/lib/analytics/__tests__/github.test.ts

 *

 * Requires: Valid GitHub OAuth token in database from a test user

 */

import { checkRateLimitStatus, enrichUser } from '../github'

async function testGitHubIntegration() {
  console.log('=== GitHub API Integration Test ===\n')

  // This would need a real token - for now just verify the functions exist
  console.log('1. Testing checkRateLimitStatus type signature...')
  console.log('   Function exists:', typeof checkRateLimitStatus === 'function')

  console.log('\n2. Testing enrichUser type signature...')
  console.log('   Function exists:', typeof enrichUser === 'function')

  console.log('\n3. Testing with mock user ID (should return null gracefully)...')
  const result = await enrichUser('nonexistent-user-id')
  console.log('   Result:', result)
  console.log('   Graceful degradation:', result === null ? 'PASS' : 'FAIL')

  console.log('\n=== Test Complete ===')
}

// Run if executed directly
testGitHubIntegration().catch(console.error)

```yaml

AVOID: Writing tests that require external API calls during CI - mock data for
automated tests.
  </action>
  <verify>

- Test file compiles without TypeScript errors
- `npx tsx src/shared/lib/analytics/__tests__/github.test.ts` runs without

  crashing

- Graceful degradation test passes (returns null for nonexistent user)

  </verify>
  <done>Integration test verifies GitHub client handles edge cases
  gracefully</done>
</task>

</tasks>

<verification>

1. TypeScript compiles: `npm run typecheck` or `npx tsc --noEmit`
2. Imports work: Test importing from `@/shared/lib/analytics` in a scratch file
3. Rate limit handling:
   - Low remaining count logs warning (check console output)
   - 403/429 status returns cached data or null (no throw)
   - Timeout prevents hanging (5 second limit)
4. Manual test: `npx tsx src/shared/lib/analytics/__tests__/github.test.ts`

</verification>

<success_criteria>

1. GitHub API client exists with proper rate limit header parsing
2. ETag-based caching reduces API calls (304 responses)
3. 24-hour cache TTL implemented for user data
4. Rate limit exhaustion returns cached/null instead of throwing
5. Warning logged when rate limit drops below 100
6. All functions properly typed and exported
7. Integration test passes with graceful degradation

</success_criteria>

<output>
After completion, create
`.planning/phases/06-github-integration-analytics/06-02-SUMMARY.md`
</output>
