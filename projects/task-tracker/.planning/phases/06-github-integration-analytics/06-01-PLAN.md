---
phase: 06-github-integration-analytics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:

  - prisma/schema.prisma
  - src/shared/lib/analytics/types.ts
  - src/shared/lib/analytics/tracker.ts
  - src/shared/lib/analytics/index.ts

autonomous: true

must_haves:
  truths:

```markdown

- "Analytics events can be stored in the database"
- "Events are validated before storage with Zod"
- "Event tracking is non-blocking using after() API"

```yaml

  artifacts:

```yaml

- path: "prisma/schema.prisma"

  provides: "AnalyticsEvent model with JSONB properties"
  contains: "model AnalyticsEvent"

- path: "src/shared/lib/analytics/types.ts"

  provides: "Zod schemas for all event types"
  exports: ["AnalyticsEventSchema", "AnalyticsEvent"]

- path: "src/shared/lib/analytics/tracker.ts"

  provides: "Core event tracking with after() API"
  exports: ["trackEvent", "trackEventAsync"]

```

  key_links:

```yaml

- from: "src/shared/lib/analytics/tracker.ts"

  to: "prisma.analyticsEvent.create"
  via: "database insert"
  pattern: "prisma\\.analyticsEvent\\.create"

- from: "src/shared/lib/analytics/tracker.ts"

  to: "after()"
  via: "non-blocking execution"
  pattern: "import.*after.*from.*next/server"

```html

---

<objective>
Create the analytics foundation: database schema, event type definitions, and
non-blocking event tracker.

Purpose: Enable automatic tracking of user behavior patterns for brain learning
without impacting user experience. This is the core infrastructure that all
other analytics features build upon.

Output: AnalyticsEvent model in database, validated event types with Zod, and a
tracker that uses Next.js 15's after() API for non-blocking writes.
</objective>

<execution_context>
@/Users/dansidanutz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dansidanutz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-github-integration-analytics/06-RESEARCH.md

# Existing code patterns to follow

@prisma/schema.prisma
@src/shared/lib/db/prisma.ts
@src/shared/lib/dal.ts
@src/app/actions/profile.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AnalyticsEvent model to Prisma schema</name>
  <files>prisma/schema.prisma</files>
  <action>
Add the AnalyticsEvent model to the existing Prisma schema with:

1. Fields per research:
   - id: String @id @default(cuid())
   - userId: String (relation to User)
   - eventType: String (e.g., 'task_created', 'file_uploaded',

```text
 'search_performed')

```

   - properties: Json (JSONB for flexible event-specific data)
   - createdAt: DateTime @default(now())

2. Relation:
   - user: User @relation(fields: [userId], references: [id], onDelete: Cascade)

3. Indexes for performance:
   - @@index([userId, createdAt]) - Fast user timeline queries
   - @@index([eventType, createdAt]) - Fast event type aggregations
   - @@index([createdAt]) - Time-series queries

4. Add AnalyticsEvent[] relation to User model

Run `npx prisma db push` to apply schema changes (dev workflow, not migration
for flexibility during development).

AVOID: GIN indexes on JSONB - research indicates they have high write overhead
and we don't need them until >100ms query times.
  </action>
  <verify>

- `npx prisma db push` succeeds without errors
- `npx prisma generate` regenerates client
- Prisma schema validates: `npx prisma validate`

  </verify>
  <done>AnalyticsEvent model exists in schema with proper indexes and User
  relation</done>
</task>

<task type="auto">
  <name>Task 2: Create event type definitions with Zod validation</name>
  <files>src/shared/lib/analytics/types.ts</files>
  <action>
Create `src/shared/lib/analytics/types.ts` with Zod schemas for all trackable
events:

1. Base event properties:
   - type: z.string() - discriminator field
   - userId: z.string() - who triggered the event
   - properties: z.record() - event-specific data

2. Define event schemas for each trackable action:

```typescript

// Page views
const PageViewEventSchema = z.object({
  type: z.literal('page_view'),
  userId: z.string(),
  properties: z.object({

```yaml

path: z.string(),
referrer: z.string().optional(),

```javascript
  })
})

// Task events (for future phases)
const TaskCreatedEventSchema = z.object({
  type: z.literal('task_created'),
  userId: z.string(),
  properties: z.object({

```yaml

taskId: z.string(),
hasDescription: z.boolean(),
category: z.string().optional(),

```
  })
})

const TaskUpdatedEventSchema = z.object({
  type: z.literal('task_updated'),
  userId: z.string(),
  properties: z.object({

```yaml

taskId: z.string(),
fieldsChanged: z.array(z.string()),
newStatus: z.string().optional(),

```javascript
  })
})

const TaskDeletedEventSchema = z.object({
  type: z.literal('task_deleted'),
  userId: z.string(),
  properties: z.object({

```yaml

taskId: z.string(),

```
  })
})

// File events (for future phases)
const FileUploadedEventSchema = z.object({
  type: z.literal('file_uploaded'),
  userId: z.string(),
  properties: z.object({

```yaml

fileId: z.string(),
taskId: z.string(),
fileSize: z.number(),
mimeType: z.string(),

```javascript
  })
})

// Search events (for future phases)
const SearchPerformedEventSchema = z.object({
  type: z.literal('search_performed'),
  userId: z.string(),
  properties: z.object({

```yaml

query: z.string(),
resultsCount: z.number(),
filters: z.record(z.unknown()).optional(),

```
  })
})

// Auth events
const LoginEventSchema = z.object({
  type: z.literal('login'),
  userId: z.string(),
  properties: z.object({

```yaml

provider: z.string(),
isNewUser: z.boolean(),

```javascript
  })
})

const LogoutEventSchema = z.object({
  type: z.literal('logout'),
  userId: z.string(),
  properties: z.object({})
})

// Profile events
const ProfileUpdatedEventSchema = z.object({
  type: z.literal('profile_updated'),
  userId: z.string(),
  properties: z.object({

```yaml

fieldsChanged: z.array(z.string()),

```
  })
})

```yaml

3. Create discriminated union:

```typescript

export const AnalyticsEventSchema = z.discriminatedUnion('type', [
  PageViewEventSchema,
  TaskCreatedEventSchema,
  TaskUpdatedEventSchema,
  TaskDeletedEventSchema,
  FileUploadedEventSchema,
  SearchPerformedEventSchema,
  LoginEventSchema,
  LogoutEventSchema,
  ProfileUpdatedEventSchema,
])

export type AnalyticsEvent = z.infer<typeof AnalyticsEventSchema>
export type EventType = AnalyticsEvent['type']

```yaml

4. Export individual schemas for type inference:

```typescript

export {
  PageViewEventSchema,
  TaskCreatedEventSchema,
  // ... etc
}

```yaml

AVOID: Storing PII in event properties - use IDs only, no emails or names.
Research emphasizes GDPR compliance.
  </action>
  <verify>

- File compiles without TypeScript errors
- `npm run typecheck` passes (or `npx tsc --noEmit`)
- Types can be imported and used in other files

  </verify>
  <done>Complete set of Zod-validated event type definitions covering all
  planned features</done>
</task>

<task type="auto">
  <name>Task 3: Create non-blocking event tracker using after() API</name>
  <files>src/shared/lib/analytics/tracker.ts,
  src/shared/lib/analytics/index.ts</files>
  <action>
Create `src/shared/lib/analytics/tracker.ts` with the core tracking logic:

1. Import required dependencies:

```typescript

import 'server-only'
import { after } from 'next/server'
import { prisma } from '@/shared/lib/db'
import { AnalyticsEventSchema, type AnalyticsEvent } from './types'

```javascript

2. Create async tracking function (used internally):

```typescript

/**

 * Track an analytics event asynchronously.
 * Validates the event and stores in database.
 * Called by trackEvent() after response is sent.

 */
export async function trackEventAsync(event: AnalyticsEvent): Promise<void> {
  try {

```javascript

// Validate event structure (will throw if invalid)
const validatedEvent = AnalyticsEventSchema.parse(event)

await prisma.analyticsEvent.create({
  data: {

```
userId: validatedEvent.userId,
eventType: validatedEvent.type,
properties: validatedEvent.properties,

```text

  }
})

```
  } catch (error) {

```yaml

// Log but don't throw - analytics should never break the app
console.error('[Analytics] Failed to track event:', error)

```yaml
  }
}

```yaml

3. Create non-blocking wrapper using after():

```typescript

/**

 * Track an analytics event without blocking the response.
 * Uses Next.js 15's after() API to defer database writes.

 *

 * @param event - The analytics event to track

 *

 * Usage in Server Actions:
 * ```
 * import { trackEvent } from '@/shared/lib/analytics'

 *

 * export async function createTask(data: FormData) {
 *   const task = await prisma.task.create(...)

 *

 *   trackEvent({
 *     type: 'task_created',
 *     userId: session.user.id,
 *     properties: { taskId: task.id, hasDescription: !!data.description }
 *   })

 *

 *   return { success: true }
 * }
 * ```

 */
export function trackEvent(event: AnalyticsEvent): void {
  after(async () => {

```text

await trackEventAsync(event)

```
  })
}

```yaml

4. Create helper for tracking with session (DRY pattern):

```typescript

import { auth } from '@/shared/lib/auth'

/**

 * Track event for current session user.
 * Convenience wrapper that auto-injects userId from session.

 *

 * @param type - Event type
 * @param properties - Event-specific properties

 */
export async function trackSessionEvent<T extends AnalyticsEvent['type']>(
  type: T,
  properties: Extract<AnalyticsEvent, { type: T }>['properties']
): Promise<void> {
  const session = await auth()
  if (!session?.user?.id) {

```yaml

console.warn('[Analytics] Cannot track event: no session')
return

```text
  }

  trackEvent({

```

type,
userId: session.user.id,
properties,

```yaml
  } as AnalyticsEvent)
}

```yaml

5. Create barrel export `src/shared/lib/analytics/index.ts`:

```typescript

export { trackEvent, trackEventAsync, trackSessionEvent } from './tracker'
export { AnalyticsEventSchema, type AnalyticsEvent, type EventType } from './types'

```yaml

CRITICAL: The after() API is only available in Server Components and Route
Handlers in Next.js 15. It will throw an error if called from Client Components.

AVOID: Awaiting trackEvent() in user-facing code - the whole point is
non-blocking. If you need to ensure tracking completes, use trackEventAsync()
but understand it adds latency.
  </action>
  <verify>

- File compiles without TypeScript errors
- Imports resolve correctly from `@/shared/lib/analytics`
- `npm run typecheck` passes
- Quick test: add temporary console.log in trackEventAsync, call

  trackSessionEvent from a test server action, verify log appears after response

  </verify>
  <done>Non-blocking event tracker using after() API with Zod validation and
  session integration</done>
</task>

</tasks>

<verification>

1. Database schema is valid: `npx prisma validate && npx prisma db push`
2. TypeScript compiles: `npm run typecheck` or `npx tsc --noEmit`
3. Analytics module exports correctly:

```typescript

import { trackEvent, trackSessionEvent, AnalyticsEventSchema } from '@/shared/lib/analytics'

```javascript

4. Event tracking works without blocking (manual test with console.log timing)

</verification>

<success_criteria>

1. AnalyticsEvent model exists in database with proper indexes
2. All event types are defined with Zod schemas for runtime validation
3. trackEvent() uses after() API for non-blocking execution
4. trackSessionEvent() helper auto-injects userId from session
5. No TypeScript errors in the analytics module
6. Pattern follows existing codebase conventions (server-only, module structure)

</success_criteria>

<output>
After completion, create
`.planning/phases/06-github-integration-analytics/06-01-SUMMARY.md`
</output>
