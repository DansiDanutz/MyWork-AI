---
phase: 08-deployment-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:

  - next.config.ts
  - src/app/api/health/route.ts
  - src/shared/lib/env.ts
  - src/middleware.ts

autonomous: true
user_setup:

  - service: neon

```yaml
why: "Serverless PostgreSQL database for production"
env_vars:

  - name: DATABASE_URL

```yaml

source: "Neon Dashboard -> Connection String (pooled)"

```

  - name: DIRECT_URL

```yaml

source: "Neon Dashboard -> Connection String (direct, for migrations)"

```
dashboard_config:

  - task: "Create new project 'task-tracker-prod'"

```yaml

location: "<https://console.neon.tech> -> New Project"

```

```yaml

  - service: vercel

```yaml
why: "Production deployment platform"
env_vars:

  - name: VERCEL_TOKEN

```

source: "Vercel Dashboard -> Settings -> Tokens -> Create"

```yaml

  - name: VERCEL_ORG_ID

```

source: "Vercel Dashboard -> Settings -> General -> Team ID"

```yaml

  - name: VERCEL_PROJECT_ID

```

source: "After Vercel project creation -> Settings -> General -> Project
ID"

```yaml
dashboard_config:

  - task: "Link GitHub repository"

```

location: "Vercel Dashboard -> Add New Project -> Import Git Repository"

```text

```

  - service: upstash

```yaml
why: "Rate limiting for abuse prevention (optional for MVP)"
env_vars:

  - name: UPSTASH_REDIS_REST_URL

```yaml

source: "Upstash Console -> Redis Database -> REST API URL"

```

  - name: UPSTASH_REDIS_REST_TOKEN

```yaml

source: "Upstash Console -> Redis Database -> REST API Token"

```
dashboard_config:

  - task: "Create Redis database (free tier available)"

```yaml

location: "<https://console.upstash.com> -> Create Database"

```

```yaml

must_haves:
  truths:

```markdown

- "Production health check endpoint returns database connectivity status"
- "Security headers protect against XSS, clickjacking, and content sniffing"
- "Environment variables are validated at startup before app runs"
- "API routes are protected against abuse with rate limiting (when Upstash

  configured)"

```

  artifacts:

```yaml

- path: "next.config.ts"

  provides: "Security headers configuration"
  contains: "X-Content-Type-Options"

- path: "src/app/api/health/route.ts"

  provides: "Enhanced health check with detailed status"
  exports: ["GET"]

- path: "src/shared/lib/env.ts"

  provides: "Production environment validation"
  contains: "envSchema"

- path: "src/middleware.ts"

  provides: "Rate limiting middleware"
  contains: "ratelimit"

```yaml

  key_links:

```yaml

- from: "src/app/api/health/route.ts"

  to: "prisma"
  via: "database connectivity check"
  pattern: "prisma\\.\\$queryRaw"

- from: "src/middleware.ts"

  to: "@upstash/ratelimit"
  via: "rate limit check"
  pattern: "Ratelimit"

```

---

<objective>
Configure production infrastructure foundation with security hardening, health
monitoring, and rate limiting.

Purpose: Establish the security and monitoring foundation required for safe
production deployment. Without these, the application would be vulnerable and
unmonitorable.

Output: Security headers configured, enhanced health check endpoint, environment
validation for production, rate limiting middleware.
</objective>

<execution_context>
@/Users/dansidanutz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dansidanutz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-deployment-validation/08-RESEARCH.md

@src/app/api/health/route.ts
@next.config.ts
@src/middleware.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add security headers to Next.js config</name>
  <files>next.config.ts</files>
  <action>
Update next.config.ts to add security headers that protect against common web
vulnerabilities:

1. Add `headers()` async function to nextConfig that returns security headers

for all paths:

   - X-Content-Type-Options: nosniff (prevents MIME sniffing)
   - X-Frame-Options: DENY (prevents clickjacking)
   - X-XSS-Protection: 1; mode=block (legacy XSS protection)
   - Referrer-Policy: strict-origin-when-cross-origin (limits referrer info)
   - Permissions-Policy: camera=(), microphone=(), geolocation=() (restrict APIs)

2. Apply headers to all routes using source: '/:path*'

3. Preserve existing config (experimental, serverExternalPackages, images)

Note: Do NOT add HSTS header - Vercel adds this automatically for HTTPS domains.
  </action>
  <verify>
Run `npm run build` - should complete successfully
Check next.config.ts contains X-Content-Type-Options, X-Frame-Options,
X-XSS-Protection
Start dev server and verify headers are sent:
  npm run dev &
  sleep 3
  curl -I <http://localhost:3000> | grep -i "X-Content-Type-Options: nosniff"
  </verify>
  <done>Security headers configured in Next.js config for all routes and
  verified via HTTP response</done>
</task>

<task type="auto">
  <name>Task 2: Enhance health check endpoint for production monitoring</name>
  <files>src/app/api/health/route.ts</files>
  <action>
Enhance the existing health check endpoint to provide detailed status
information:

1. Add uptime tracking (process.uptime())
2. Add timestamp for when check was performed
3. Add database connectivity check using `prisma.$queryRaw\`SELECT 1\``
4. Return structured response:

   ```json
   {

```yaml

 "status": "healthy" | "unhealthy",
 "checks": {
   "database": "healthy" | "unhealthy",
   "uptime": number (seconds),
   "timestamp": ISO string
 }

```python
   }

```python

5. Return 503 status code when unhealthy (database unreachable)
6. Catch database errors and include error message in response

Import prisma from @/shared/lib/prisma
  </action>
  <verify>
Start dev server: `npm run dev`
Check health endpoint: `curl <http://localhost:3000/api/health`>
Response should include status, checks.database, checks.uptime, checks.timestamp
  </verify>
  <done>Health check endpoint returns detailed status including database
  connectivity</done>
</task>

<task type="auto">
  <name>Task 3: Create production environment validation and rate
  limiting</name>
  <files>src/shared/lib/env.ts, src/middleware.ts</files>
  <action>
**Part A: Environment validation module**

Create src/shared/lib/env.ts that validates required variables at startup:

1. Define Zod schema for required production environment variables:
   - DATABASE_URL: z.string().url() - Required for Prisma
   - AUTH_SECRET: z.string().min(32) - Required for Auth.js
   - AUTH_GITHUB_ID: z.string() - Required for GitHub OAuth
   - AUTH_GITHUB_SECRET: z.string() - Required for GitHub OAuth
   - Optional: UPSTASH_REDIS_REST_URL, UPSTASH_REDIS_REST_TOKEN (for rate

```text
 limiting)

```

2. Parse process.env through schema
3. Export validated env object for use in application
4. On parse failure, the error will naturally propagate at startup

Note: Use zod (already in package.json). Do NOT add NEXTAUTH_URL - Auth.js v5
infers this automatically.

**Part B: Rate limiting middleware**

Update src/middleware.ts to add rate limiting using @upstash/ratelimit:

1. Install @upstash/ratelimit if not present: `npm install @upstash/ratelimit

@upstash/redis`

2. At top of middleware.ts, add conditional rate limiting:

   ```typescript

   import { Ratelimit } from '@upstash/ratelimit'
   import { Redis } from '@upstash/redis'

   // Only create ratelimiter if Upstash is configured
   const ratelimit = process.env.UPSTASH_REDIS_REST_URL

```yaml

 ? new Ratelimit({

```yaml
 redis: Redis.fromEnv(),
 limiter: Ratelimit.slidingWindow(60, '1 m'), // 60 requests per minute
 analytics: true,

```

   })
 : null

```yaml

```yaml

3. In the middleware function, apply rate limiting to API routes only:

   ```typescript

   // Rate limit API routes (if Upstash is configured)
   if (ratelimit && request.nextUrl.pathname.startsWith('/api')) {

```

 const ip = request.headers.get('x-forwarded-for') ?? 'anonymous'
 const { success, remaining, reset } = await ratelimit.limit(ip)

 if (!success) {
   return new NextResponse('Too Many Requests', {

```yaml
 status: 429,
 headers: {
   'X-RateLimit-Remaining': remaining.toString(),
   'X-RateLimit-Reset': reset.toString(),
 },

```

   })
 }

```yaml
   }

```yaml

4. Place rate limiting check BEFORE existing auth checks
5. Gracefully skip rate limiting if Upstash env vars not set (MVP friendly)

Note: Rate limiting is optional for MVP - works when UPSTASH_* env vars are set,
silently skips otherwise.
  </action>
  <verify>
Check files exist:
  ls src/shared/lib/env.ts src/middleware.ts

TypeScript compiles:
  npx tsc --noEmit src/shared/lib/env.ts

Env schema includes DATABASE_URL, AUTH_SECRET, AUTH_GITHUB_ID,
AUTH_GITHUB_SECRET

Middleware includes rate limiting imports and conditional Ratelimit check

npm run build succeeds (will gracefully skip rate limiting without Upstash env
vars)
  </verify>
  <done>Environment validation module validates required production variables;
  Rate limiting middleware protects API routes when Upstash is configured</done>
</task>

</tasks>

<verification>

- [ ] npm run build succeeds
- [ ] Security headers in next.config.ts (X-Content-Type-Options,

  X-Frame-Options)

- [ ] curl -I localhost:3000 returns X-Content-Type-Options: nosniff header
- [ ] Health endpoint returns structured JSON with database status
- [ ] Environment validation file exists with Zod schema
- [ ] Rate limiting middleware in place (conditional on Upstash config)

</verification>

<success_criteria>

- Security headers protect against XSS, clickjacking, content sniffing (verified

  via HTTP response)

- Health check endpoint returns database connectivity status
- Environment validation catches missing required variables at startup
- Rate limiting protects API routes when Upstash is configured (graceful

  degradation without)

</success_criteria>

<output>
After completion, create
`.planning/phases/08-deployment-validation/08-01-SUMMARY.md`
</output>
