---
phase: 05-file-attachments
plan: 04
type: execute
wave: 4
depends_on: ["05-02", "05-03"]
files_modified:
  - src/shared/components/FileDropzone.tsx
  - src/shared/components/FileUploadProgress.tsx
  - src/shared/components/index.ts
autonomous: true

must_haves:
  truths:
    - "User can drag and drop files to upload"
    - "Upload progress is visible with percentage"
    - "User can cancel in-progress uploads"
    - "Upload errors show clear messages"
  artifacts:
    - path: "src/shared/components/FileDropzone.tsx"
      provides: "Drag and drop file upload component"
      min_lines: 100
    - path: "src/shared/components/FileUploadProgress.tsx"
      provides: "Upload progress display with cancel"
      min_lines: 50
  key_links:
    - from: "src/shared/components/FileDropzone.tsx"
      to: "/api/files/upload"
      via: "TUS client"
      pattern: "tus-js-client|uploadFile"
---

<objective>
Create the file upload UI components with drag & drop and progress tracking.

Purpose: Users need an intuitive way to attach files to tasks. The FileDropzone component provides modern drag & drop UX with progress feedback and error handling.

Output: FileDropzone.tsx, FileUploadProgress.tsx components
</objective>

<execution_context>
@/Users/dansidanutz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dansidanutz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-file-attachments/05-CONTEXT.md
@src/shared/lib/file-validation.ts
@src/app/actions/files.ts
@src/shared/components/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FileUploadProgress component</name>
  <files>src/shared/components/FileUploadProgress.tsx</files>
  <action>
Create src/shared/components/FileUploadProgress.tsx:

```tsx
'use client'

import { formatFileSize } from '@/shared/lib/file-validation'

export type UploadStatus = 'pending' | 'uploading' | 'complete' | 'error'

export interface UploadState {
  id: string
  filename: string
  size: number
  progress: number
  status: UploadStatus
  error?: string
}

interface FileUploadProgressProps {
  uploads: UploadState[]
  onCancel: (id: string) => void
  onRetry?: (id: string) => void
  onDismiss?: (id: string) => void
}

export function FileUploadProgress({
  uploads,
  onCancel,
  onRetry,
  onDismiss,
}: FileUploadProgressProps) {
  if (uploads.length === 0) return null

  return (
    <div className="space-y-2 mt-4">
      {uploads.map((upload) => (
        <div
          key={upload.id}
          className="border border-zinc-700 rounded-lg p-3 bg-zinc-800/50"
        >
          {/* File info row */}
          <div className="flex items-center justify-between mb-2">
            <div className="flex items-center gap-2 min-w-0 flex-1">
              <FileIcon mimeType={getMimeFromFilename(upload.filename)} />
              <span className="text-sm text-zinc-200 truncate">
                {upload.filename}
              </span>
              <span className="text-xs text-zinc-500 flex-shrink-0">
                {formatFileSize(upload.size)}
              </span>
            </div>

            {/* Action button */}
            <div className="flex-shrink-0 ml-2">
              {upload.status === 'uploading' && (
                <button
                  onClick={() => onCancel(upload.id)}
                  className="text-xs text-red-400 hover:text-red-300 px-2 py-1"
                  title="Cancel upload"
                >
                  Cancel
                </button>
              )}
              {upload.status === 'error' && onRetry && (
                <button
                  onClick={() => onRetry(upload.id)}
                  className="text-xs text-blue-400 hover:text-blue-300 px-2 py-1"
                  title="Retry upload"
                >
                  Retry
                </button>
              )}
              {(upload.status === 'complete' || upload.status === 'error') && onDismiss && (
                <button
                  onClick={() => onDismiss(upload.id)}
                  className="text-xs text-zinc-400 hover:text-zinc-300 px-2 py-1"
                  title="Dismiss"
                >
                  Dismiss
                </button>
              )}
            </div>
          </div>

          {/* Progress bar */}
          {upload.status === 'uploading' && (
            <div className="mb-1">
              <div className="w-full bg-zinc-700 rounded-full h-1.5">
                <div
                  className="bg-blue-500 h-1.5 rounded-full transition-all duration-300"
                  style={{ width: `${upload.progress}%` }}
                />
              </div>
              <div className="flex justify-between mt-1">
                <span className="text-xs text-zinc-400">Uploading...</span>
                <span className="text-xs text-zinc-400">{upload.progress.toFixed(0)}%</span>
              </div>
            </div>
          )}

          {/* Status messages */}
          {upload.status === 'complete' && (
            <div className="flex items-center gap-1.5">
              <CheckIcon className="w-4 h-4 text-green-500" />
              <span className="text-xs text-green-500">Upload complete</span>
            </div>
          )}

          {upload.status === 'error' && (
            <div className="flex items-center gap-1.5">
              <ErrorIcon className="w-4 h-4 text-red-500" />
              <span className="text-xs text-red-500">
                {upload.error || 'Upload failed'}
              </span>
            </div>
          )}

          {upload.status === 'pending' && (
            <div className="flex items-center gap-1.5">
              <span className="text-xs text-zinc-400">Waiting...</span>
            </div>
          )}
        </div>
      ))}
    </div>
  )
}

// Helper function to guess MIME type from filename
function getMimeFromFilename(filename: string): string {
  const ext = filename.split('.').pop()?.toLowerCase() || ''
  const mimeMap: Record<string, string> = {
    jpg: 'image/jpeg',
    jpeg: 'image/jpeg',
    png: 'image/png',
    gif: 'image/gif',
    webp: 'image/webp',
    pdf: 'application/pdf',
    doc: 'application/msword',
    docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    xls: 'application/vnd.ms-excel',
    xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    txt: 'text/plain',
    csv: 'text/csv',
    zip: 'application/zip',
  }
  return mimeMap[ext] || 'application/octet-stream'
}

// File type icon component
function FileIcon({ mimeType }: { mimeType: string }) {
  const isImage = mimeType.startsWith('image/')
  const isPdf = mimeType === 'application/pdf'
  const isDoc = mimeType.includes('word') || mimeType.includes('document')
  const isSpreadsheet = mimeType.includes('excel') || mimeType.includes('spreadsheet')

  let color = 'text-zinc-400'
  let icon = 'M4 4h16v16H4V4z' // Generic file

  if (isImage) {
    color = 'text-purple-400'
    icon = 'M4 5a2 2 0 012-2h12a2 2 0 012 2v14a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm4 4a2 2 0 100 4 2 2 0 000-4zm8 8l-3-3-2 2-1-1-4 4h10z'
  } else if (isPdf) {
    color = 'text-red-400'
  } else if (isDoc) {
    color = 'text-blue-400'
  } else if (isSpreadsheet) {
    color = 'text-green-400'
  }

  return (
    <svg className={`w-5 h-5 ${color}`} fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d={icon} />
    </svg>
  )
}

// Check icon for success
function CheckIcon({ className }: { className?: string }) {
  return (
    <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
    </svg>
  )
}

// Error icon
function ErrorIcon({ className }: { className?: string }) {
  return (
    <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
    </svg>
  )
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles.
Check file: `ls src/shared/components/FileUploadProgress.tsx`
  </verify>
  <done>
- FileUploadProgress shows upload list with progress bars
- Cancel, retry, dismiss actions available
- File type icons for different MIME types
- Progress percentage displayed
- Error messages shown clearly
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FileDropzone component</name>
  <files>src/shared/components/FileDropzone.tsx</files>
  <action>
Create src/shared/components/FileDropzone.tsx:

```tsx
'use client'

import { useCallback, useState, useRef } from 'react'
import { useDropzone } from 'react-dropzone'
import * as tus from 'tus-js-client'
import { uploadFile } from '@/app/actions/files'
import {
  MAX_FILE_SIZE,
  SERVER_ACTION_SIZE_LIMIT,
  formatFileSize,
  validateFileSize,
} from '@/shared/lib/file-validation'
import { FileUploadProgress, UploadState } from './FileUploadProgress'

interface FileDropzoneProps {
  taskId: string
  onUploadComplete?: (fileId: string, filename: string) => void
  onUploadError?: (filename: string, error: string) => void
  maxFiles?: number
  disabled?: boolean
  compact?: boolean
}

export function FileDropzone({
  taskId,
  onUploadComplete,
  onUploadError,
  maxFiles = 10,
  disabled = false,
  compact = false,
}: FileDropzoneProps) {
  const [uploads, setUploads] = useState<UploadState[]>([])
  const tusUploadsRef = useRef<Map<string, tus.Upload>>(new Map())

  // Update upload state helper
  const updateUpload = useCallback((id: string, updates: Partial<UploadState>) => {
    setUploads((prev) =>
      prev.map((u) => (u.id === id ? { ...u, ...updates } : u))
    )
  }, [])

  // Remove upload from list
  const removeUpload = useCallback((id: string) => {
    setUploads((prev) => prev.filter((u) => u.id !== id))
    tusUploadsRef.current.delete(id)
  }, [])

  // Handle small file upload via Server Action
  const uploadSmallFile = useCallback(
    async (file: File, uploadId: string) => {
      const formData = new FormData()
      formData.append('file', file)
      formData.append('taskId', taskId)

      const result = await uploadFile(formData)

      if (result.success) {
        updateUpload(uploadId, { status: 'complete', progress: 100 })
        onUploadComplete?.(result.fileId!, result.filename!)
      } else {
        updateUpload(uploadId, {
          status: 'error',
          error: result.error || 'Upload failed',
        })
        onUploadError?.(file.name, result.error || 'Upload failed')
      }
    },
    [taskId, onUploadComplete, onUploadError, updateUpload]
  )

  // Handle large file upload via TUS
  const uploadLargeFile = useCallback(
    (file: File, uploadId: string) => {
      const upload = new tus.Upload(file, {
        endpoint: '/api/files/upload',
        retryDelays: [0, 3000, 5000, 10000, 20000],
        chunkSize: 5 * 1024 * 1024, // 5MB chunks
        metadata: {
          filename: file.name,
          filetype: file.type,
          taskId,
        },
        onProgress: (bytesUploaded, bytesTotal) => {
          const progress = (bytesUploaded / bytesTotal) * 100
          updateUpload(uploadId, { progress, status: 'uploading' })
        },
        onSuccess: () => {
          updateUpload(uploadId, { status: 'complete', progress: 100 })
          // TUS creates DB record on server side, so we don't have fileId here
          // The UI should refresh to show the new file
          onUploadComplete?.('', file.name)
          tusUploadsRef.current.delete(uploadId)
        },
        onError: (error) => {
          const errorMessage = error.message || 'Upload failed'
          updateUpload(uploadId, { status: 'error', error: errorMessage })
          onUploadError?.(file.name, errorMessage)
          tusUploadsRef.current.delete(uploadId)
        },
      })

      tusUploadsRef.current.set(uploadId, upload)
      upload.start()
    },
    [taskId, onUploadComplete, onUploadError, updateUpload]
  )

  // Process dropped files
  const onDrop = useCallback(
    (acceptedFiles: File[]) => {
      // Limit number of files
      const filesToUpload = acceptedFiles.slice(0, maxFiles)

      filesToUpload.forEach((file) => {
        // Generate unique ID for this upload
        const uploadId = `${file.name}-${Date.now()}-${Math.random()}`

        // Validate file size
        const sizeValidation = validateFileSize(file.size)
        if (!sizeValidation.isValid) {
          setUploads((prev) => [
            ...prev,
            {
              id: uploadId,
              filename: file.name,
              size: file.size,
              progress: 0,
              status: 'error',
              error: sizeValidation.error,
            },
          ])
          onUploadError?.(file.name, sizeValidation.error!)
          return
        }

        // Add to upload list
        setUploads((prev) => [
          ...prev,
          {
            id: uploadId,
            filename: file.name,
            size: file.size,
            progress: 0,
            status: 'uploading',
          },
        ])

        // Choose upload method based on file size
        if (file.size <= SERVER_ACTION_SIZE_LIMIT) {
          // Small file: use Server Action
          uploadSmallFile(file, uploadId)
        } else {
          // Large file: use TUS protocol
          uploadLargeFile(file, uploadId)
        }
      })
    },
    [maxFiles, uploadSmallFile, uploadLargeFile, onUploadError]
  )

  // Cancel an upload
  const handleCancel = useCallback((id: string) => {
    const tusUpload = tusUploadsRef.current.get(id)
    if (tusUpload) {
      tusUpload.abort()
    }
    removeUpload(id)
  }, [removeUpload])

  // Retry a failed upload
  const handleRetry = useCallback(
    (id: string) => {
      const upload = uploads.find((u) => u.id === id)
      if (upload) {
        // Reset status and re-trigger
        updateUpload(id, { status: 'uploading', progress: 0, error: undefined })

        // Find original file (we need to re-drop it)
        // For now, just remove and ask user to re-drop
        removeUpload(id)
      }
    },
    [uploads, updateUpload, removeUpload]
  )

  // Dismiss completed/errored upload
  const handleDismiss = useCallback(
    (id: string) => {
      removeUpload(id)
    },
    [removeUpload]
  )

  // Setup dropzone
  const { getRootProps, getInputProps, isDragActive, isDragReject } = useDropzone({
    onDrop,
    disabled,
    maxSize: MAX_FILE_SIZE,
    multiple: true,
  })

  // Active uploads count
  const activeUploads = uploads.filter((u) => u.status === 'uploading').length

  return (
    <div className="w-full">
      <div
        {...getRootProps()}
        className={`
          border-2 border-dashed rounded-lg transition-colors cursor-pointer
          ${compact ? 'p-4' : 'p-8'}
          ${isDragActive && !isDragReject ? 'border-blue-500 bg-blue-500/10' : ''}
          ${isDragReject ? 'border-red-500 bg-red-500/10' : ''}
          ${!isDragActive && !isDragReject ? 'border-zinc-600 hover:border-zinc-500' : ''}
          ${disabled ? 'opacity-50 cursor-not-allowed' : ''}
        `}
      >
        <input {...getInputProps()} />

        <div className={`text-center ${compact ? '' : 'space-y-2'}`}>
          {/* Upload icon */}
          <svg
            className={`mx-auto text-zinc-400 ${compact ? 'w-6 h-6' : 'w-10 h-10'}`}
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={1.5}
              d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"
            />
          </svg>

          {isDragActive ? (
            <p className={`text-blue-400 ${compact ? 'text-sm' : ''}`}>
              Drop files here...
            </p>
          ) : (
            <>
              <p className={`text-zinc-300 ${compact ? 'text-sm' : ''}`}>
                Drag & drop files here
              </p>
              {!compact && (
                <p className="text-zinc-500 text-sm">
                  or click to select files (max {formatFileSize(MAX_FILE_SIZE)} per file)
                </p>
              )}
            </>
          )}

          {activeUploads > 0 && (
            <p className="text-xs text-zinc-500 mt-1">
              {activeUploads} upload{activeUploads > 1 ? 's' : ''} in progress
            </p>
          )}
        </div>
      </div>

      {/* Upload progress list */}
      <FileUploadProgress
        uploads={uploads}
        onCancel={handleCancel}
        onRetry={handleRetry}
        onDismiss={handleDismiss}
      />
    </div>
  )
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles.
Check file: `ls src/shared/components/FileDropzone.tsx`
  </verify>
  <done>
- FileDropzone with react-dropzone for drag & drop
- Small files (< 5MB) use Server Action
- Large files use TUS protocol with chunking
- Progress tracking for all uploads
- Cancel, retry, dismiss functionality
- Visual feedback for drag states
- Compact mode for embedding in forms
  </done>
</task>

<task type="auto">
  <name>Task 3: Export new components</name>
  <files>src/shared/components/index.ts</files>
  <action>
Update src/shared/components/index.ts to export the new file components:

```typescript
// Existing exports
export { ProfileForm } from './ProfileForm'
export { TaskCard } from './TaskCard'
export { TaskEditForm } from './TaskEditForm'
export { TaskForm } from './TaskForm'
export { TaskList } from './TaskList'
export { UserMenu } from './UserMenu'
export { TagBadge } from './TagBadge'
export { TagInput } from './TagInput'
export { TaskFilters } from './TaskFilters'
export { TaskSearchBar } from './TaskSearchBar'
export { TaskFormWithTags } from './TaskFormWithTags'
export { TaskEditFormWithTags } from './TaskEditFormWithTags'
export { TaskListWithFilters } from './TaskListWithFilters'
export { EmptyState } from './EmptyState'

// File upload components
export { FileDropzone } from './FileDropzone'
export { FileUploadProgress } from './FileUploadProgress'
export type { UploadState, UploadStatus } from './FileUploadProgress'
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles.
Check exports: `grep -n "FileDropzone" src/shared/components/index.ts`
  </verify>
  <done>
- FileDropzone exported from components index
- FileUploadProgress exported
- UploadState and UploadStatus types exported
  </done>
</task>

</tasks>

<verification>
1. Run `npx tsc --noEmit` - no TypeScript errors
2. Run `npm run build` - verify build succeeds
3. Check components export correctly from index
</verification>

<success_criteria>
- FileDropzone supports drag & drop file upload
- Progress bars show upload percentage
- Cancel button stops in-progress uploads
- Error messages display clearly
- Small files use Server Action, large files use TUS
- Components exported from shared/components/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/05-file-attachments/05-04-SUMMARY.md`
</output>
