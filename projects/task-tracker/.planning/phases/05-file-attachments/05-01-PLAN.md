---
phase: 05-file-attachments
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:

  - prisma/schema.prisma
  - src/shared/lib/file-validation.ts
  - next.config.ts
  - package.json

autonomous: true

must_haves:
  truths:

```markdown

- "FileAttachment model exists in database schema"
- "File validation utility can detect MIME types by content"
- "Server Actions body size limit is configured for 5MB"

```yaml

  artifacts:

```yaml

- path: "prisma/schema.prisma"

  provides: "FileAttachment model with Task relation"
  contains: "model FileAttachment"

- path: "src/shared/lib/file-validation.ts"

  provides: "Content-based file type validation"
  exports: ["validateFileType", "validateFileSize", "ALLOWED_MIME_TYPES",
  "MAX_FILE_SIZE"]

```yaml

  key_links:

```yaml

- from: "prisma/schema.prisma"

  to: "Task model"
  via: "FileAttachment.taskId foreign key"
  pattern: "taskId.*Task.*onDelete: Cascade"

```html

---

<objective>
Create the database schema for file attachments and core file validation
utilities.

Purpose: Establish the data model and security foundation for file uploads.
Content-based MIME validation is critical for security - we must validate actual
file content, not just extensions.

Output: FileAttachment Prisma model, file-validation.ts utility, updated
next.config.ts with body size limit
</objective>

<execution_context>
@/Users/dansidanutz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dansidanutz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-file-attachments/05-CONTEXT.md
@.planning/phases/05-file-attachments/05-RESEARCH.md
@prisma/schema.prisma
@next.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and configure Next.js</name>
  <files>package.json, next.config.ts</files>
  <action>
Install file upload dependencies:

```bash
npm install react-dropzone file-type sharp
npm install tus-js-client @tus/server @tus/file-store
npm install -D @types/sharp

```yaml

Update next.config.ts to increase Server Actions body size limit:

```typescript

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  experimental: {

```yaml

serverActions: {
  bodySizeLimit: '5mb', // Increased for file uploads (small files via Server
  Actions)
},

```
  },
  images: {

```yaml

remotePatterns: [], // Will add patterns if needed for thumbnails

```javascript
  },
};

export default nextConfig;

```yaml

Note: Files larger than 5MB will use TUS protocol via dedicated API routes.
  </action>
  <verify>
Run `npm ls react-dropzone file-type sharp tus-js-client` to confirm all
packages installed.
Run `cat next.config.ts | grep bodySizeLimit` to confirm config updated.
  </verify>
  <done>

- react-dropzone, file-type, sharp installed
- tus-js-client and @tus/server installed
- next.config.ts has bodySizeLimit: '5mb'

  </done>
</task>

<task type="auto">
  <name>Task 2: Add FileAttachment model to Prisma schema</name>
  <files>prisma/schema.prisma</files>
  <action>
Add FileAttachment model to prisma/schema.prisma (after Tag model):

```prisma

// File attachments for tasks
model FileAttachment {
  id              String   @id @default(cuid())
  taskId          String
  task            Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  userId          String   // Denormalized for direct ownership checks

  // File metadata
  filename        String   @db.VarChar(255)  // Original filename for display
  storedFilename  String   @db.VarChar(255)  // UUID-based filename on disk
  mimeType        String   @db.VarChar(100)
  size            Int                        // File size in bytes

  // Optional thumbnail for images
  thumbnailPath   String?  @db.VarChar(500)

  createdAt       DateTime @default(now())

  @@index([taskId])
  @@index([userId])
  @@map("file_attachments")
}

```yaml

Update Task model to add attachments relation:

```prisma

model Task {
  // ... existing fields ...

  // Add this relation
  attachments FileAttachment[]

  // ... existing indexes ...
}

```yaml

Run migration:

```bash
npx prisma db push
npx prisma generate

```html

  </action>
  <verify>
Run `npx prisma db push --force-reset` if needed (dev environment).
Run `npx prisma studio` and verify FileAttachment table exists with correct
columns.
Check that Task model shows attachments relation.
  </verify>
  <done>

- FileAttachment model exists in schema
- Task model has attachments relation
- Cascade delete configured (files deleted when task deleted)
- Migration applied successfully

  </done>
</task>

<task type="auto">
  <name>Task 3: Create file validation utility</name>
  <files>src/shared/lib/file-validation.ts</files>
  <action>
Create src/shared/lib/file-validation.ts:

```typescript

import { fileTypeFromBuffer } from 'file-type'

// Allowed MIME types - whitelist approach for security
export const ALLOWED_MIME_TYPES = [
  // Images
  'image/jpeg',
  'image/png',
  'image/gif',
  'image/webp',
  'image/svg+xml',

  // Documents
  'application/pdf',
  'application/msword',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  'application/vnd.ms-excel',
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  'application/vnd.ms-powerpoint',
  'application/vnd.openxmlformats-officedocument.presentationml.presentation',

  // Text
  'text/plain',
  'text/csv',
  'text/markdown',

  // Archives
  'application/zip',
  'application/x-rar-compressed',
  'application/gzip',
] as const

export type AllowedMimeType = typeof ALLOWED_MIME_TYPES[number]

// 25MB per file (from CONTEXT.md)
export const MAX_FILE_SIZE = 25 * 1024 * 1024

// 5MB threshold for Server Actions vs TUS protocol
export const SERVER_ACTION_SIZE_LIMIT = 5 * 1024 * 1024

export interface FileValidationResult {
  isValid: boolean
  error?: string
  mime?: string
  ext?: string
}

/**

 * Validate file type by reading magic bytes (binary signature).
 * This is security-critical - NEVER trust client-provided MIME types or extensions.

 */
export async function validateFileType(buffer: Buffer): Promise<FileValidationResult> {
  try {

```javascript

const type = await fileTypeFromBuffer(buffer)

if (!type) {
  // Could be a text file (no magic bytes)
  // Try to detect if it's valid text
  const isText = isValidTextFile(buffer)
  if (isText) {

```yaml
return {
  isValid: true,
  mime: 'text/plain',
  ext: 'txt',
}

```

  }
  return {

```yaml
isValid: false,
error: 'Unable to detect file type. File may be corrupted.',

```yaml

  }
}

if (!ALLOWED_MIME_TYPES.includes(type.mime as AllowedMimeType)) {
  return {

```yaml
isValid: false,
error: `File type "${type.mime}" is not allowed. Supported types: images,
documents, text files, and archives.`,
mime: type.mime,

```

  }
}

return {
  isValid: true,
  mime: type.mime,
  ext: type.ext,
}

```yaml
  } catch (error) {

```yaml

console.error('File type validation error:', error)
return {
  isValid: false,
  error: 'Failed to validate file type.',
}

```markdown

  }
}

/**

 * Validate file size against limit.

 */
export function validateFileSize(size: number): FileValidationResult {
  if (size > MAX_FILE_SIZE) {

```javascript

const sizeMB = (size / 1024 / 1024).toFixed(2)
const limitMB = MAX_FILE_SIZE / 1024 / 1024
return {
  isValid: false,
  error: `File size (${sizeMB}MB) exceeds the ${limitMB}MB limit.`,
}

```yaml
  }

  if (size === 0) {

```yaml

return {
  isValid: false,
  error: 'File is empty.',
}

```
  }

  return { isValid: true }
}

/**

 * Check if buffer appears to be valid UTF-8 text.
 * Used for text files that don't have magic bytes.

 */
function isValidTextFile(buffer: Buffer): boolean {
  // Check first 1KB for valid UTF-8
  const sample = buffer.slice(0, 1024)

  try {

```javascript

const text = sample.toString('utf-8')
// Check for null bytes (binary indicator)
if (text.includes('\0')) {
  return false
}
// Check if it decodes back to same bytes (valid UTF-8)
const reencoded = Buffer.from(text, 'utf-8')
return sample.equals(reencoded)

```text
  } catch {

```text

return false

```markdown

  }
}

/**

 * Get human-readable file size string.

 */
export function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 Bytes'

  const k = 1024
  const sizes = ['Bytes', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))

  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
}

/**

 * Check if file should use TUS protocol (large file).

 */
export function shouldUseTusProtocol(size: number): boolean {
  return size > SERVER_ACTION_SIZE_LIMIT
}

/**

 * Get file extension from MIME type.

 */
export function getExtensionFromMime(mime: string): string {
  const mimeToExt: Record<string, string> = {

```yaml

'image/jpeg': 'jpg',
'image/png': 'png',
'image/gif': 'gif',
'image/webp': 'webp',
'image/svg+xml': 'svg',
'application/pdf': 'pdf',
'application/msword': 'doc',
'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
'docx',
'application/vnd.ms-excel': 'xls',
'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 'xlsx',
'application/vnd.ms-powerpoint': 'ppt',
'application/vnd.openxmlformats-officedocument.presentationml.presentation':
'pptx',
'text/plain': 'txt',
'text/csv': 'csv',
'text/markdown': 'md',
'application/zip': 'zip',
'application/x-rar-compressed': 'rar',
'application/gzip': 'gz',

```bash
  }

  return mimeToExt[mime] || 'bin'
}

/**

 * Check if MIME type is an image (for thumbnail generation).

 */
export function isImageMime(mime: string): boolean {
  return mime.startsWith('image/') && mime !== 'image/svg+xml'
}

```html

  </action>
  <verify>
Create a simple test:

```bash
node -e "
const { validateFileSize, formatFileSize, MAX_FILE_SIZE } = require('./src/shared/lib/file-validation.ts');
console.log('MAX_FILE_SIZE:', MAX_FILE_SIZE);
console.log('Format 1MB:', formatFileSize(1024*1024));
console.log('Validate 10MB:', validateFileSize(10*1024*1024));
console.log('Validate 30MB:', validateFileSize(30*1024*1024));
"

```yaml

Or check with TypeScript compilation: `npx tsc --noEmit`
  </verify>
  <done>

- file-validation.ts exports validateFileType, validateFileSize
- ALLOWED_MIME_TYPES whitelist defined
- MAX_FILE_SIZE is 25MB
- Helper functions for size formatting, extension mapping
- isImageMime helper for thumbnail generation decision

  </done>
</task>

</tasks>

<verification>

1. Run `npx prisma studio` - FileAttachment table should exist
2. Run `npm run build` - no TypeScript errors
3. Check next.config.ts has bodySizeLimit configured
4. Verify file-validation.ts exports work with `npx tsc --noEmit`

</verification>

<success_criteria>

- FileAttachment model in Prisma schema with Task cascade delete
- file-validation.ts provides content-based MIME validation
- next.config.ts configured for 5MB Server Actions
- All dependencies installed (react-dropzone, file-type, sharp, tus-*)
- TypeScript compiles without errors

</success_criteria>

<output>
After completion, create `.planning/phases/05-file-attachments/05-01-SUMMARY.md`
</output>
