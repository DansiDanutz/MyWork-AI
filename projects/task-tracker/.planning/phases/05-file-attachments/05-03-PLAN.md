---
phase: 05-file-attachments
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:

  - src/shared/lib/thumbnail-generator.ts
  - src/app/actions/files.ts
  - src/shared/lib/dal.ts
  - src/app/api/files/download/[id]/route.ts

autonomous: true

must_haves:
  truths:

```markdown

- "Thumbnail generator creates WebP thumbnails for images"
- "Server Actions can upload files via FormData"
- "Download endpoint serves files with authentication"
- "DAL has file-related query functions"

```yaml

  artifacts:

```yaml

- path: "src/shared/lib/thumbnail-generator.ts"

  provides: "Sharp-based thumbnail generation"
  exports: ["generateThumbnail"]

- path: "src/app/actions/files.ts"

  provides: "Server Actions for file operations"
  exports: ["uploadFile", "deleteFileAction"]

- path: "src/app/api/files/download/[id]/route.ts"

  provides: "Authenticated file download endpoint"
  exports: ["GET"]

```yaml

  key_links:

```yaml

- from: "src/app/actions/files.ts"

  to: "prisma.fileAttachment"
  via: "database operations"
  pattern: "prisma\\.fileAttachment\\.(create|delete)"

- from: "src/app/api/files/download/[id]/route.ts"

  to: "file-storage.ts"
  via: "readFile function"
  pattern: "readFile"

```html

---

<objective>
Implement thumbnail generation, Server Actions for file operations, and secure
download endpoint.

Purpose: Server Actions handle small file uploads (< 5MB) directly without TUS
complexity. The download endpoint ensures files are served with proper
authentication and ownership checks.

Output: thumbnail-generator.ts, files.ts Server Actions, download API route, DAL
updates
</objective>

<execution_context>
@/Users/dansidanutz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dansidanutz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-file-attachments/05-CONTEXT.md
@.planning/phases/05-file-attachments/05-RESEARCH.md
@src/shared/lib/file-validation.ts
@src/shared/lib/file-storage.ts
@src/shared/lib/dal.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create thumbnail generator with Sharp</name>
  <files>src/shared/lib/thumbnail-generator.ts</files>
  <action>
Replace the placeholder with full implementation in
src/shared/lib/thumbnail-generator.ts:

```typescript

import sharp from 'sharp'
import path from 'path'
import fs from 'fs/promises'
import { getThumbnailDir } from '@/shared/lib/file-storage'

// Thumbnail configuration
const THUMBNAIL_SIZE = 200 // pixels (square)
const THUMBNAIL_QUALITY = 80

/**

 * Generate a WebP thumbnail for an image file.
 * Returns the relative thumbnail path (for storage in DB) or null if generation fails.

 */
export async function generateThumbnail(
  sourcePath: string,
  userId: string,
  taskId: string,
  storedFilename: string
): Promise<string | null> {
  try {

```javascript

// Get thumbnail directory
const thumbDir = await getThumbnailDir(userId, taskId)

// Generate thumbnail filename (same base name, .webp extension)
const baseName = path.basename(storedFilename, path.extname(storedFilename))
const thumbFilename = `${baseName}.webp`
const thumbPath = path.join(thumbDir, thumbFilename)

// Generate thumbnail with Sharp
await sharp(sourcePath)
  .resize(THUMBNAIL_SIZE, THUMBNAIL_SIZE, {

```
fit: 'cover',      // Crop to fill square
position: 'center', // Center the crop

```yaml

  })
  .webp({ quality: THUMBNAIL_QUALITY })
  .toFile(thumbPath)

// Return relative path for DB storage
// Format: userId/taskId/thumbs/filename.webp
return path.join(userId, taskId, 'thumbs', thumbFilename)

```yaml
  } catch (error) {

```yaml

console.error('Thumbnail generation failed:', error)
return null

```markdown

  }
}

/**

 * Delete a thumbnail file.

 */
export async function deleteThumbnail(relativePath: string): Promise<void> {
  const fullPath = path.join(process.cwd(), 'uploads', relativePath)

  try {

```text

await fs.unlink(fullPath)

```
  } catch {

```text

// Ignore if file doesn't exist

```markdown

  }
}

/**

 * Check if a file is a supported image format for thumbnail generation.

 */
export function canGenerateThumbnail(mimeType: string): boolean {
  const supported = [

```yaml

'image/jpeg',
'image/png',
'image/gif',
'image/webp',
// Note: SVG excluded - Sharp can convert but may have security issues

```markdown

  ]

  return supported.includes(mimeType)
}

/**

 * Get thumbnail URL for a file attachment.
 * Returns null if no thumbnail exists.

 */
export function getThumbnailUrl(thumbnailPath: string | null): string | null {
  if (!thumbnailPath) return null
  // Thumbnails are served via the download endpoint
  return `/api/files/thumbnail/${encodeURIComponent(thumbnailPath)}`
}

```html

  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles.
Check file: `ls src/shared/lib/thumbnail-generator.ts`
  </verify>
  <done>

- generateThumbnail uses Sharp to create 200px WebP thumbnails
- canGenerateThumbnail checks if MIME type supports thumbnails
- Returns relative path for DB storage
- Error handling doesn't crash upload flow

  </done>
</task>

<task type="auto">
  <name>Task 2: Create Server Actions for file operations</name>
  <files>src/app/actions/files.ts</files>
  <action>
Create src/app/actions/files.ts:

```typescript

'use server'

import { auth } from '@/shared/lib/auth'
import { prisma } from '@/shared/lib/db'
import { revalidatePath } from 'next/cache'
import {
  validateFileType,
  validateFileSize,
  isImageMime,
  getExtensionFromMime,
  SERVER_ACTION_SIZE_LIMIT,
} from '@/shared/lib/file-validation'
import { saveFile, deleteFile as deleteFileFromDisk } from '@/shared/lib/file-storage'
import { generateThumbnail, canGenerateThumbnail, deleteThumbnail } from '@/shared/lib/thumbnail-generator'
import { trackEvent } from '@/shared/lib/analytics'

interface UploadResult {
  success: boolean
  error?: string
  fileId?: string
  filename?: string
}

/**

 * Upload a file via Server Action (for files < 5MB).
 * Larger files should use the TUS endpoint.

 */
export async function uploadFile(formData: FormData): Promise<UploadResult> {
  try {

```javascript

// Authenticate
const session = await auth()
if (!session?.user?.id) {
  return { success: false, error: 'Unauthorized' }
}

const userId = session.user.id

// Get file and taskId from form data
const file = formData.get('file') as File | null
const taskId = formData.get('taskId') as string | null

if (!file) {
  return { success: false, error: 'No file provided' }
}

if (!taskId) {
  return { success: false, error: 'No task ID provided' }
}

// Check file size for Server Action limit
if (file.size > SERVER_ACTION_SIZE_LIMIT) {
  return {

```yaml
success: false,
error: `File too large for direct upload. Files over 5MB should use the
upload endpoint.`,

```

  }
}

// Validate file size (overall limit)
const sizeValidation = validateFileSize(file.size)
if (!sizeValidation.isValid) {
  return { success: false, error: sizeValidation.error }
}

// Verify user owns the task
const task = await prisma.task.findFirst({
  where: { id: taskId, userId },
})

if (!task) {
  return { success: false, error: 'Task not found or access denied' }
}

// Read file content
const buffer = Buffer.from(await file.arrayBuffer())

// Validate file type by content (security-critical)
const typeValidation = await validateFileType(buffer)
if (!typeValidation.isValid) {
  return { success: false, error: typeValidation.error }
}

// Save file to disk
const extension = typeValidation.ext ||
getExtensionFromMime(typeValidation.mime!)
const { storedFilename, filePath } = await saveFile(buffer, userId, taskId,
extension)

// Generate thumbnail for images
let thumbnailPath: string | null = null
if (canGenerateThumbnail(typeValidation.mime!)) {
  thumbnailPath = await generateThumbnail(filePath, userId, taskId,
  storedFilename)
}

// Create database record
const attachment = await prisma.fileAttachment.create({
  data: {

```yaml
taskId,
userId,
filename: file.name,
storedFilename,
mimeType: typeValidation.mime!,
size: file.size,
thumbnailPath,

```yaml

  },
})

// Track analytics
await trackEvent(userId, 'file_uploaded', {
  taskId,
  fileId: attachment.id,
  mimeType: typeValidation.mime,
  size: file.size,
  hasThumbnail: !!thumbnailPath,
})

// Revalidate task page
revalidatePath(`/tasks/${taskId}`)
revalidatePath(`/tasks/${taskId}/edit`)

return {
  success: true,
  fileId: attachment.id,
  filename: file.name,
}

```yaml
  } catch (error) {

```yaml

console.error('Upload error:', error)
return {
  success: false,
  error: 'An unexpected error occurred during upload',
}

```
  }
}

/**

 * Delete a file attachment.

 */
export async function deleteFileAction(fileId: string): Promise<{ success: boolean; error?: string }> {
  try {

```javascript

// Authenticate
const session = await auth()
if (!session?.user?.id) {
  return { success: false, error: 'Unauthorized' }
}

const userId = session.user.id

// Find file and verify ownership
const file = await prisma.fileAttachment.findFirst({
  where: { id: fileId, userId },
  include: { task: true },
})

if (!file) {
  return { success: false, error: 'File not found or access denied' }
}

// Delete from filesystem
await deleteFileFromDisk(userId, file.taskId, file.storedFilename,
file.thumbnailPath)

// Delete thumbnail if exists
if (file.thumbnailPath) {
  await deleteThumbnail(file.thumbnailPath)
}

// Delete from database
await prisma.fileAttachment.delete({
  where: { id: fileId },
})

// Track analytics
await trackEvent(userId, 'file_deleted', {
  taskId: file.taskId,
  fileId,
  mimeType: file.mimeType,
})

// Revalidate
revalidatePath(`/tasks/${file.taskId}`)
revalidatePath(`/tasks/${file.taskId}/edit`)

return { success: true }

```yaml
  } catch (error) {

```yaml

console.error('Delete file error:', error)
return { success: false, error: 'Failed to delete file' }

```markdown

  }
}

/**

 * Get file attachments for a task.

 */
export async function getTaskFiles(taskId: string) {
  const session = await auth()
  if (!session?.user?.id) {

```text

return []

```javascript
  }

  const files = await prisma.fileAttachment.findMany({

```yaml

where: { taskId, userId: session.user.id },
orderBy: { createdAt: 'desc' },

```
  })

  return files
}

```html

  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles.
Check file: `ls src/app/actions/files.ts`
  </verify>
  <done>

- uploadFile handles small files via Server Action
- deleteFileAction removes file from disk and DB
- getTaskFiles retrieves files for a task
- Analytics tracking integrated
- Authentication and ownership verified

  </done>
</task>

<task type="auto">
  <name>Task 3: Create download and DAL functions</name>
  <files>src/app/api/files/download/[id]/route.ts, src/shared/lib/dal.ts</files>
  <action>
Create src/app/api/files/download/[id]/route.ts:

```typescript

import { NextRequest, NextResponse } from 'next/server'
import { auth } from '@/shared/lib/auth'
import { prisma } from '@/shared/lib/db'
import { readFile } from '@/shared/lib/file-storage'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {

```javascript

// Authenticate
const session = await auth()
if (!session?.user?.id) {
  return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
}

const { id } = await params

// Find file and verify ownership
const file = await prisma.fileAttachment.findFirst({
  where: { id, userId: session.user.id },
})

if (!file) {
  return NextResponse.json({ error: 'File not found' }, { status: 404 })
}

// Read file from disk
const buffer = await readFile(session.user.id, file.taskId, file.storedFilename)

if (!buffer) {
  return NextResponse.json({ error: 'File not found on disk' }, { status: 404 })
}

// Determine if this should be displayed inline or downloaded
const isInlineViewable = file.mimeType.startsWith('image/') || file.mimeType ===
'application/pdf'
const disposition = isInlineViewable ? 'inline' : 'attachment'

// Return file with appropriate headers
return new NextResponse(buffer, {
  status: 200,
  headers: {

```yaml
'Content-Type': file.mimeType,
'Content-Length': file.size.toString(),
'Content-Disposition': `${disposition};
filename="${encodeURIComponent(file.filename)}"`,
'Cache-Control': 'private, max-age=3600', // Cache for 1 hour

```text

  },
})

```text
  } catch (error) {

```

console.error('Download error:', error)
return NextResponse.json({ error: 'Internal server error' }, { status: 500 })

```yaml
  }
}

```yaml

Add file-related DAL functions to src/shared/lib/dal.ts (append to existing
file):

```typescript

// Add these imports at top if not present:
// import { FileAttachment } from '@prisma/client'

/**

 * Get all file attachments for a task with ownership verification.

 */
export const getFilesByTask = cache(async (
  taskId: string,
  userId: string
): Promise<FileAttachment[]> => {
  try {

```javascript

const files = await prisma.fileAttachment.findMany({
  where: { taskId, userId },
  orderBy: { createdAt: 'desc' },
})
return files

```text
  } catch (error) {

```yaml

console.error('Error fetching task files:', error)
return []

```markdown

  }
})

/**

 * Get a single file attachment with ownership verification.

 */
export const getFile = cache(async (
  fileId: string,
  userId: string
): Promise<FileAttachment | null> => {
  try {

```javascript

const file = await prisma.fileAttachment.findFirst({
  where: { id: fileId, userId },
})
return file

```text
  } catch (error) {

```

console.error('Error fetching file:', error)
return null

```markdown

  }
})

/**

 * Get file count for a task (for UI indicators).

 */
export const getTaskFileCount = cache(async (
  taskId: string,
  userId: string
): Promise<number> => {
  try {

```javascript

const count = await prisma.fileAttachment.count({
  where: { taskId, userId },
})
return count

```text
  } catch (error) {

```yaml

console.error('Error counting task files:', error)
return 0

```markdown

  }
})

/**

 * Get task with files included.

 */
export const getTaskWithFiles = cache(async (
  taskId: string,
  userId: string
): Promise<(Task & { attachments: FileAttachment[], tags: Tag[] }) | null> => {
  try {

```javascript

const task = await prisma.task.findFirst({
  where: { id: taskId, userId },
  include: {

```
attachments: {
  orderBy: { createdAt: 'desc' },
},
tags: true,

```text

  },
})
return task

```text
  } catch (error) {

```yaml

console.error('Error fetching task with files:', error)
return null

```text
  }
})

```python

Also add the FileAttachment import at the top of dal.ts:

```typescript

import { Task, TaskStatus, Tag, FileAttachment, Prisma } from '@prisma/client'

```html

  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles.
Check routes: `ls -la src/app/api/files/`
Check DAL: `grep -n "getFilesByTask" src/shared/lib/dal.ts`
  </verify>
  <done>

- Download route at /api/files/download/[id]
- Authentication and ownership verification
- Proper Content-Type and Content-Disposition headers
- DAL has getFilesByTask, getFile, getTaskFileCount, getTaskWithFiles
- FileAttachment type imported

  </done>
</task>

</tasks>

<verification>

1. Run `npx tsc --noEmit` - no TypeScript errors
2. Run `npm run build` - verify build succeeds
3. Check that all files are created in correct locations
4. Verify DAL exports new functions

</verification>

<success_criteria>

- thumbnail-generator.ts creates 200px WebP thumbnails with Sharp
- Server Actions uploadFile and deleteFileAction work
- Download endpoint serves files with auth
- DAL has file query functions (getFilesByTask, getFile, getTaskWithFiles)
- All operations verify ownership
- Analytics tracking integrated

</success_criteria>

<output>
After completion, create `.planning/phases/05-file-attachments/05-03-SUMMARY.md`
</output>
