---
phase: 05-file-attachments
plan: 02
type: execute
wave: 3
depends_on: ["05-01", "05-03"]
files_modified:

  - src/shared/lib/file-storage.ts
  - src/app/api/files/upload/route.ts
  - uploads/.gitkeep
  - .gitignore

autonomous: true

must_haves:
  truths:

```
- "TUS upload endpoint accepts chunked file uploads"
- "File storage utility creates user/task directory structure"
- "Uploads directory is gitignored but exists"

```
  artifacts:

```
- path: "src/shared/lib/file-storage.ts"

  provides: "File system operations for upload/storage"
  exports: ["getUploadDir", "saveFile", "deleteFile", "ensureUploadDir"]

- path: "src/app/api/files/upload/route.ts"

  provides: "TUS protocol upload endpoint"
  exports: ["POST", "HEAD", "PATCH", "OPTIONS", "DELETE"]

```
  key_links:

```
- from: "src/app/api/files/upload/route.ts"

  to: "uploads/"
  via: "TUS FileStore"
  pattern: "FileStore.*directory"

- from: "src/app/api/files/upload/route.ts"

  to: "src/shared/lib/thumbnail-generator.ts"
  via: "generateThumbnail import"
  pattern: "import.*generateThumbnail"

```
---

<objective>
Implement file storage utilities and TUS protocol upload endpoint for resumable
large file uploads.

Purpose: TUS protocol enables 25MB file uploads with resume capability after
network interruptions. The file storage utility provides a clean abstraction for
filesystem operations with proper directory structure.

Output: file-storage.ts utility, TUS upload API route at /api/files/upload
</objective>

<execution_context>
@/Users/dansidanutz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dansidanutz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-file-attachments/05-CONTEXT.md
@.planning/phases/05-file-attachments/05-RESEARCH.md
@src/shared/lib/file-validation.ts
@src/shared/lib/thumbnail-generator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create uploads directory and gitignore config</name>
  <files>uploads/.gitkeep, .gitignore</files>
  <action>
Create the uploads directory structure:

```bash
mkdir -p uploads/temp
touch uploads/.gitkeep
touch uploads/temp/.gitkeep

```yaml

Update .gitignore to exclude uploaded files but keep directory:

```

# Add to .gitignore

# Uploaded files (keep directory structure)

uploads/*
!uploads/.gitkeep
uploads/temp/*
!uploads/temp/.gitkeep

```yaml

The directory structure will be:

```
uploads/
├── .gitkeep
├── temp/           # TUS temporary uploads
│   └── .gitkeep
└── [userId]/       # Created dynamically

```
└── [taskId]/
    ├── [fileId].ext
    └── thumbs/
        └── [fileId].webp

```
```html

  </action>
  <verify>
Run `ls -la uploads/` to confirm directory exists.
Run `git status` to confirm uploads directory is properly gitignored.
  </verify>
  <done>

- uploads/ directory exists with .gitkeep
- uploads/temp/ directory exists for TUS
- .gitignore configured to exclude file contents but keep structure

  </done>
</task>

<task type="auto">
  <name>Task 2: Create file storage utility</name>
  <files>src/shared/lib/file-storage.ts</files>
  <action>
Create src/shared/lib/file-storage.ts:

```typescript

import fs from 'fs/promises'
import path from 'path'

// Base upload directory (relative to project root)
const UPLOAD_BASE = path.join(process.cwd(), 'uploads')
const TEMP_DIR = path.join(UPLOAD_BASE, 'temp')

/**

 * Get the upload directory for a specific user and task.
 * Creates the directory if it doesn't exist.

 */
export async function getUploadDir(userId: string, taskId: string): Promise<string> {
  const dir = path.join(UPLOAD_BASE, userId, taskId)
  await fs.mkdir(dir, { recursive: true })
  return dir
}

/**

 * Get the thumbnail directory for a specific user and task.
 * Creates the directory if it doesn't exist.

 */
export async function getThumbnailDir(userId: string, taskId: string): Promise<string> {
  const dir = path.join(UPLOAD_BASE, userId, taskId, 'thumbs')
  await fs.mkdir(dir, { recursive: true })
  return dir
}

/**

 * Get the temp directory for TUS uploads.
 * Creates if doesn't exist.

 */
export async function getTempDir(): Promise<string> {
  await fs.mkdir(TEMP_DIR, { recursive: true })
  return TEMP_DIR
}

/**

 * Ensure base upload directories exist.
 * Call on server startup.

 */
export async function ensureUploadDir(): Promise<void> {
  await fs.mkdir(UPLOAD_BASE, { recursive: true })
  await fs.mkdir(TEMP_DIR, { recursive: true })
}

/**

 * Save a file buffer to the user's upload directory.
 * Returns the stored filename (UUID-based).

 */
export async function saveFile(
  buffer: Buffer,
  userId: string,
  taskId: string,
  extension: string
): Promise<{ storedFilename: string; filePath: string }> {
  const uploadDir = await getUploadDir(userId, taskId)
  const storedFilename = `${crypto.randomUUID()}.${extension}`
  const filePath = path.join(uploadDir, storedFilename)

  await fs.writeFile(filePath, buffer)

  return { storedFilename, filePath }
}

/**

 * Move a file from temp to final location (for TUS uploads).

 */
export async function moveFromTemp(
  tempFilename: string,
  userId: string,
  taskId: string,
  extension: string
): Promise<{ storedFilename: string; filePath: string }> {
  const tempPath = path.join(TEMP_DIR, tempFilename)
  const uploadDir = await getUploadDir(userId, taskId)
  const storedFilename = `${crypto.randomUUID()}.${extension}`
  const filePath = path.join(uploadDir, storedFilename)

  await fs.rename(tempPath, filePath)

  // Clean up TUS metadata files
  try {

```
await fs.unlink(`${tempPath}.json`).catch(() => {})

```
  } catch {

```
// Ignore cleanup errors

```
  }

  return { storedFilename, filePath }
}

/**

 * Delete a file and its thumbnail if exists.

 */
export async function deleteFile(
  userId: string,
  taskId: string,
  storedFilename: string,
  thumbnailPath?: string | null
): Promise<void> {
  const filePath = path.join(UPLOAD_BASE, userId, taskId, storedFilename)

  try {

```
await fs.unlink(filePath)

```
  } catch (error) {

```
// File might already be deleted, log but don't fail
console.warn('Failed to delete file:', filePath, error)

```
  }

  // Delete thumbnail if exists
  if (thumbnailPath) {

```
try {
  const thumbPath = thumbnailPath.startsWith('/')
    ? thumbnailPath
    : path.join(UPLOAD_BASE, thumbnailPath)
  await fs.unlink(thumbPath)
} catch {
  // Thumbnail might not exist, ignore
}

```
  }
}

/**

 * Delete all files for a task (cleanup when task is deleted).
 * Prisma cascade handles DB records, this handles filesystem.

 */
export async function deleteTaskFiles(userId: string, taskId: string): Promise<void> {
  const taskDir = path.join(UPLOAD_BASE, userId, taskId)

  try {

```
await fs.rm(taskDir, { recursive: true, force: true })

```
  } catch (error) {

```
console.warn('Failed to delete task directory:', taskDir, error)

```
  }
}

/**

 * Read a file from storage.
 * Returns null if file doesn't exist.

 */
export async function readFile(
  userId: string,
  taskId: string,
  storedFilename: string
): Promise<Buffer | null> {
  const filePath = path.join(UPLOAD_BASE, userId, taskId, storedFilename)

  try {

```
return await fs.readFile(filePath)

```
  } catch {

```
return null

```
  }
}

/**

 * Get the full file path for a stored file.

 */
export function getFilePath(userId: string, taskId: string, storedFilename: string): string {
  return path.join(UPLOAD_BASE, userId, taskId, storedFilename)
}

/**

 * Check if a file exists.

 */
export async function fileExists(
  userId: string,
  taskId: string,
  storedFilename: string
): Promise<boolean> {
  const filePath = getFilePath(userId, taskId, storedFilename)

  try {

```
await fs.access(filePath)
return true

```
  } catch {

```
return false

```
  }
}

/**

 * Clean up old temp files (older than 24 hours).
 * Run periodically to prevent temp directory bloat.

 */
export async function cleanupTempFiles(): Promise<number> {
  const maxAge = 24 * 60 * 60 * 1000 // 24 hours in ms
  const now = Date.now()
  let deleted = 0

  try {

```
const files = await fs.readdir(TEMP_DIR)

for (const file of files) {
  if (file === '.gitkeep') continue

  const filePath = path.join(TEMP_DIR, file)
  const stats = await fs.stat(filePath)

  if (now - stats.mtimeMs > maxAge) {
    await fs.unlink(filePath).catch(() => {})
    deleted++
  }
}

```
  } catch (error) {

```
console.warn('Temp cleanup error:', error)

```
  }

  return deleted
}

```

  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles.
Check file exists: `ls src/shared/lib/file-storage.ts`
  </verify>
  <done>

- file-storage.ts exports all directory and file operations
- getUploadDir creates user/task structure
- saveFile stores with UUID filename
- deleteFile cleans up file and thumbnail
- moveFromTemp handles TUS uploads
- cleanupTempFiles for maintenance

  </done>
</task>

<task type="auto">
  <name>Task 3: Create TUS upload API route</name>
  <files>src/app/api/files/upload/route.ts</files>
  <action>
Create src/app/api/files/upload/route.ts:

```typescript

import { Server, Upload } from '@tus/server'
import { FileStore } from '@tus/file-store'
import { NextRequest, NextResponse } from 'next/server'
import path from 'path'
import { auth } from '@/shared/lib/auth'
import { prisma } from '@/shared/lib/db'
import { validateFileType, isImageMime, getExtensionFromMime, MAX_FILE_SIZE } from '@/shared/lib/file-validation'
import { moveFromTemp, getThumbnailDir } from '@/shared/lib/file-storage'
import { generateThumbnail } from '@/shared/lib/thumbnail-generator'
import fs from 'fs/promises'

const TEMP_DIR = path.join(process.cwd(), 'uploads', 'temp')

// Ensure temp directory exists
fs.mkdir(TEMP_DIR, { recursive: true }).catch(() => {})

// TUS server configuration
const tusServer = new Server({
  path: '/api/files/upload',
  datastore: new FileStore({ directory: TEMP_DIR }),
  maxSize: MAX_FILE_SIZE,

  // Called when upload is complete
  async onUploadFinish(req, res, upload: Upload) {

```
try {
  // Get metadata from upload
  const taskId = upload.metadata?.taskId
  const originalFilename = upload.metadata?.filename || 'unnamed'
  const userId = upload.metadata?.userId

  if (!taskId || !userId) {
    console.error('TUS upload missing required metadata:', upload.metadata)
    // Can't throw here, just log - TUS protocol requires 2xx response
    return res
  }

  // Verify user owns the task
  const task = await prisma.task.findFirst({
    where: { id: taskId, userId },
  })

  if (!task) {
    console.error('TUS upload: task not found or access denied')
    return res
  }

  // Read uploaded file for validation
  const tempPath = path.join(TEMP_DIR, upload.id)
  const buffer = await fs.readFile(tempPath)

  // Validate file type by content
  const typeValidation = await validateFileType(buffer)
  if (!typeValidation.isValid) {
    console.error('TUS upload: invalid file type:', typeValidation.error)
    // Clean up invalid file
    await fs.unlink(tempPath).catch(() => {})
    return res
  }

  // Move to permanent location
  const extension = typeValidation.ext || getExtensionFromMime(typeValidation.mime!)
  const { storedFilename, filePath } = await moveFromTemp(
    upload.id,
    userId,
    taskId,
    extension
  )

  // Generate thumbnail for images
  let thumbnailPath: string | null = null
  if (isImageMime(typeValidation.mime!)) {
    try {
      thumbnailPath = await generateThumbnail(filePath, userId, taskId, storedFilename)
    } catch (error) {
      console.warn('Thumbnail generation failed:', error)
      // Continue without thumbnail
    }
  }

  // Create database record
  await prisma.fileAttachment.create({
    data: {
      taskId,
      userId,
      filename: originalFilename,
      storedFilename,
      mimeType: typeValidation.mime!,
      size: upload.size || buffer.length,
      thumbnailPath,
    },
  })

  console.log('TUS upload complete:', { taskId, filename: originalFilename, size: upload.size })
} catch (error) {
  console.error('TUS onUploadFinish error:', error)
}

return res

```
  },
})

// Helper to verify auth and add userId to metadata
async function getAuthenticatedUserId(): Promise<string | null> {
  try {

```
const session = await auth()
return session?.user?.id || null

```
  } catch {

```
return null

```
  }
}

// TUS endpoint handlers
export async function POST(request: NextRequest) {
  // Verify authentication
  const userId = await getAuthenticatedUserId()
  if (!userId) {

```
return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })

```
  }

  // Clone request and add userId to metadata header
  // TUS client sends metadata in Upload-Metadata header
  const uploadMetadata = request.headers.get('Upload-Metadata') || ''
  const newMetadata = uploadMetadata ? `${uploadMetadata},userId ${Buffer.from(userId).toString('base64')}` : `userId ${Buffer.from(userId).toString('base64')}`

  const headers = new Headers(request.headers)
  headers.set('Upload-Metadata', newMetadata)

  const modifiedRequest = new NextRequest(request.url, {

```
method: request.method,
headers,
body: request.body,
duplex: 'half',

```
  } as RequestInit)

  return tusServer.handle(modifiedRequest)
}

export async function HEAD(request: NextRequest) {
  const userId = await getAuthenticatedUserId()
  if (!userId) {

```
return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })

```
  }

  return tusServer.handle(request)
}

export async function PATCH(request: NextRequest) {
  const userId = await getAuthenticatedUserId()
  if (!userId) {

```
return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })

```
  }

  return tusServer.handle(request)
}

export async function OPTIONS(request: NextRequest) {
  // OPTIONS doesn't need auth (CORS preflight)
  return tusServer.handle(request)
}

export async function DELETE(request: NextRequest) {
  const userId = await getAuthenticatedUserId()
  if (!userId) {

```
return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })

```
  }

  return tusServer.handle(request)
}

// Disable body parsing for TUS (it handles its own streaming)
export const config = {
  api: {

```
bodyParser: false,

```
  },
}

```python

Note: This plan depends on 05-03 which creates thumbnail-generator.ts. The
import will resolve to the real implementation.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compiles.
Check file exists: `ls src/app/api/files/upload/route.ts`
The actual endpoint testing will be done after UI components are ready.
  </verify>
  <done>

- TUS upload route exists at /api/files/upload
- POST, HEAD, PATCH, OPTIONS, DELETE handlers implemented
- Authentication required for all operations except OPTIONS
- onUploadFinish validates file type and creates DB record
- File moved from temp to permanent location after upload
- userId injected into metadata for security

  </done>
</task>

</tasks>

<verification>

1. Run `npx tsc --noEmit` - no TypeScript errors
2. Run `ls uploads/` - directory structure exists
3. Run `git status` - uploads/** is gitignored
4. Check API route exists: `ls src/app/api/files/upload/`

</verification>

<success_criteria>

- uploads/ directory exists and is gitignored
- file-storage.ts provides filesystem abstraction
- TUS upload route handles POST/HEAD/PATCH/OPTIONS/DELETE
- Authentication enforced on TUS endpoints
- File validation runs on upload complete
- Database record created after successful upload

</success_criteria>

<output>
After completion, create `.planning/phases/05-file-attachments/05-02-SUMMARY.md`
</output>
