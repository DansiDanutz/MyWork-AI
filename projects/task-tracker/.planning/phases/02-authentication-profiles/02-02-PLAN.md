---
phase: 02-authentication-profiles
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:

  - src/shared/lib/dal.ts
  - src/middleware.ts
  - src/shared/hooks/useDebounce.ts

autonomous: true

must_haves:
  truths:

```markdown

- "Protected routes redirect unauthenticated users to /login"
- "verifySession function redirects to login if not authenticated"
- "getUser function returns current user data with caching"
- "useDebounce hook prevents excessive API calls on rapid input"

```yaml

  artifacts:

```yaml

- path: "src/shared/lib/dal.ts"

  provides: "Data Access Layer with authorization checks"
  exports: ["verifySession", "getUser"]

- path: "src/middleware.ts"

  provides: "Route protection middleware"
  exports: ["middleware", "config"]

- path: "src/shared/hooks/useDebounce.ts"

  provides: "Debounce hook for auto-save pattern"
  exports: ["useDebounce"]

```yaml

  key_links:

```yaml

- from: "src/shared/lib/dal.ts"

  to: "src/shared/lib/auth.ts"
  via: "imports auth function"
  pattern: "import.*auth.*from.*auth"

- from: "src/middleware.ts"

  to: "src/shared/lib/auth.ts"
  via: "imports auth function"
  pattern: "import.*auth.*from.*auth"

```html

---

<objective>
Create authorization layer with Data Access Layer (DAL), middleware for route
protection, and useDebounce hook for auto-save functionality.

Purpose: Provide reusable authorization patterns that all protected features
will use. The DAL centralizes auth checks with React cache() to prevent
duplicate queries. Middleware provides fast route-level protection.

Output: DAL with verifySession/getUser, middleware protecting /settings and
/dashboard routes, useDebounce hook for profile auto-save.
</objective>

<execution_context>
@/Users/dansidanutz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dansidanutz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-profiles/02-CONTEXT.md
@.planning/phases/02-authentication-profiles/02-RESEARCH.md

# Dependencies from 02-01

@src/shared/lib/auth.ts
@src/shared/lib/db/prisma.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Data Access Layer (DAL)</name>
  <files>src/shared/lib/dal.ts</files>
  <action>
Create src/shared/lib/dal.ts with authorization utilities using React cache()
for deduplication.

```typescript

import 'server-only'
import { cache } from 'react'
import { auth } from '@/shared/lib/auth'
import { prisma } from '@/shared/lib/db'
import { redirect } from 'next/navigation'

/**

 * Verify the current session and redirect to login if not authenticated.
 * Uses React cache() to prevent duplicate auth checks within the same request.

 *

 * @returns Object with isAuth flag and userId
 * @throws Redirects to /login if not authenticated

 */
export const verifySession = cache(async () => {
  const session = await auth()

  if (!session?.user?.id) {

```text

redirect('/login')

```
  }

  return { isAuth: true, userId: session.user.id }
})

/**

 * Get the current authenticated user with profile data.
 * Calls verifySession first to ensure authentication.
 * Uses React cache() to prevent duplicate database queries.

 *

 * @returns User object with profile fields, or null if not found

 */
export const getUser = cache(async () => {
  const { userId } = await verifySession()

  const user = await prisma.user.findUnique({

```yaml

where: { id: userId },
select: {
  id: true,
  name: true,
  email: true,
  image: true,
  bio: true,
  customAvatar: true,
  createdAt: true,
  updatedAt: true,
  // Exclude sensitive fields like accounts/sessions
}

```markdown

  })

  return user
})

/**

 * Get session without redirect - for checking auth status in UI.
 * Use this when you want to show different content for auth/unauth users
 * rather than forcing a redirect.

 */
export const getSession = cache(async () => {
  return await auth()
})

```yaml

IMPORTANT:

- 'server-only' import ensures this module can't be imported from client

  components

- cache() from React deduplicates calls within the same request
- verifySession redirects to /login, while getSession returns null (for

  conditional rendering)

  </action>
  <verify>

- File exists at src/shared/lib/dal.ts
- `npx tsc --noEmit` passes with no type errors
- Exports verifySession, getUser, getSession

  </verify>
  <done>
Data Access Layer created with cached authorization functions. Ready for use in
Server Components and Server Actions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Route Protection Middleware</name>
  <files>src/middleware.ts</files>
  <action>
Create src/middleware.ts for lightweight route protection.

```typescript

import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import { auth } from '@/shared/lib/auth'

// Routes that require authentication
const protectedRoutes = ['/settings', '/dashboard', '/tasks']

// Routes that authenticated users should be redirected away from
const authRoutes = ['/login']

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl

  // Get session (lightweight check via auth())
  const session = await auth()
  const isAuthenticated = !!session?.user

  // Check if current path is protected
  const isProtectedRoute = protectedRoutes.some(route =>

```text

pathname.startsWith(route)

```javascript
  )

  // Check if current path is auth-only (login page)
  const isAuthRoute = authRoutes.some(route =>

```bash

pathname === route || pathname.startsWith(route)

```python
  )

  // Redirect unauthenticated users away from protected routes
  if (isProtectedRoute && !isAuthenticated) {

```javascript

const loginUrl = new URL('/login', request.url)
// Preserve the original URL for redirect after login
loginUrl.searchParams.set('callbackUrl', pathname)
return NextResponse.redirect(loginUrl)

```
  }

  // Redirect authenticated users away from login page
  if (isAuthRoute && isAuthenticated) {

```text

return NextResponse.redirect(new URL('/dashboard', request.url))

```javascript
  }

  return NextResponse.next()
}

export const config = {
  matcher: [

```yaml

/*

 * Match all request paths except:
 * - api/auth (Auth.js routes - let them handle their own auth)
 * - _next/static (static files)
 * - _next/image (image optimization files)
 * - favicon.ico (favicon file)
 * - public files (images, etc.)

 */
'/((?!api/auth|_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',

```yaml
  ],
}

```yaml

IMPORTANT per RESEARCH.md:

- Do NOT query database in middleware (performance issue)
- auth() function only checks session cookie, doesn't hit DB
- Use DAL verifySession in Server Components for full auth validation

  </action>
  <verify>

- File exists at src/middleware.ts (root of src/, not in app/)
- `npm run build` succeeds
- `npm run dev` starts without middleware errors

  </verify>
  <done>
Middleware protects /settings, /dashboard, /tasks routes. Authenticated users
redirected from /login to /dashboard.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useDebounce Hook</name>
  <files>src/shared/hooks/useDebounce.ts, src/shared/hooks/index.ts</files>
  <action>

1. Create hooks directory and useDebounce hook at

src/shared/hooks/useDebounce.ts:

```typescript

'use client'

import { useEffect, useCallback, useRef } from 'react'

/**

 * Debounce a callback function to prevent excessive calls.
 * Used for auto-save pattern per CONTEXT.md requirements.

 *

 * @param callback - Function to debounce
 * @param delay - Delay in milliseconds (default 3000ms per RESEARCH.md recommendation)
 * @returns Debounced version of the callback

 *

 * @example
 * const handleChange = useDebounce((value: string) => {
 *   saveToServer(value)
 * }, 3000)

 */
export function useDebounce<T extends (...args: unknown[]) => unknown>(
  callback: T,
  delay: number = 3000
): (...args: Parameters<T>) => void {
  const timeoutRef = useRef<NodeJS.Timeout | null>(null)
  const callbackRef = useRef(callback)

  // Update callback ref on each render to capture latest closure
  useEffect(() => {

```javascript

callbackRef.current = callback

```javascript
  }, [callback])

  // Cleanup on unmount
  useEffect(() => {

```

return () => {
  if (timeoutRef.current) {

```text
clearTimeout(timeoutRef.current)

```javascript

  }
}

```javascript
  }, [])

  const debouncedCallback = useCallback((...args: Parameters<T>) => {

```javascript

// Clear existing timeout
if (timeoutRef.current) {
  clearTimeout(timeoutRef.current)
}

// Set new timeout
timeoutRef.current = setTimeout(() => {
  callbackRef.current(...args)
}, delay)

```yaml
  }, [delay])

  return debouncedCallback
}

```yaml

2. Create index file for hooks at src/shared/hooks/index.ts:

```typescript

export { useDebounce } from './useDebounce'

```

3. Create directory if needed:

```bash
mkdir -p src/shared/hooks

```yaml

NOTE: The hook uses callbackRef pattern to always call the latest callback
version without requiring it in dependencies. This prevents stale closure issues
common with debounce implementations.
  </action>
  <verify>

- File exists at src/shared/hooks/useDebounce.ts
- File exists at src/shared/hooks/index.ts
- `npx tsc --noEmit` passes with no type errors
- Hook exports useDebounce function

  </verify>
  <done>
useDebounce hook created with proper cleanup and stale closure prevention. Ready
for profile auto-save.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Type checking:
   - `npx tsc --noEmit` passes with no errors

2. Build verification:
   - `npm run build` completes successfully

3. Module verification:
   - DAL exports: verifySession, getUser, getSession
   - Middleware exports: middleware, config
   - Hook exports: useDebounce

4. Runtime verification:
   - `npm run dev` starts without errors
   - Visiting /settings without auth should redirect to /login

</verification>

<success_criteria>

- [ ] src/shared/lib/dal.ts exports verifySession, getUser, getSession
- [ ] src/middleware.ts protects /settings, /dashboard, /tasks routes
- [ ] src/shared/hooks/useDebounce.ts provides debounce functionality
- [ ] All files pass TypeScript compilation
- [ ] Build succeeds without errors
- [ ] Unauthenticated access to /settings redirects to /login

</success_criteria>

<output>
After completion, create
`.planning/phases/02-authentication-profiles/02-02-SUMMARY.md`
</output>
