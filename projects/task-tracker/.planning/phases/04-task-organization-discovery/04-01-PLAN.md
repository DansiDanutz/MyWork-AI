---
phase: 04-task-organization-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:

  - prisma/schema.prisma
  - prisma/migrations/XXX_add_tags_and_search/migration.sql
  - src/shared/lib/dal.ts
  - src/app/actions/tasks.ts
  - src/app/actions/tags.ts

autonomous: true

must_haves:
  truths:

```
- "Tags table exists in database with name uniqueness"
- "Tasks can be associated with multiple tags via many-to-many relation"
- "Full-text search vector exists on tasks table"
- "GIN indexes exist for search_vector and trigrams"

```
  artifacts:

```
- path: "prisma/schema.prisma"

  provides: "Tag model and Task-Tag implicit relation"
  contains: "model Tag"

- path: "prisma/migrations/XXX_add_tags_and_search/migration.sql"

  provides: "PostgreSQL extensions, tsvector column, GIN indexes"
  contains: "CREATE EXTENSION"

- path: "src/shared/lib/dal.ts"

  provides: "getTagsByUser, searchTasks, filterTasks DAL functions"
  exports: ["getTagsByUser", "searchTasks", "filterTasks"]

- path: "src/app/actions/tags.ts"

  provides: "Server Actions for tag CRUD"
  exports: ["createTag", "deleteTag", "updateTaskTags"]

```
  key_links:

```
- from: "prisma/schema.prisma"

  to: "src/shared/lib/dal.ts"
  via: "Prisma client queries"
  pattern: "prisma\\.tag\\.(find|create)"

- from: "src/app/actions/tags.ts"

  to: "prisma.tag"
  via: "Server Action to database"
  pattern: "prisma\\.task\\.update.*tags"

```
---

<objective>
Add tag model for task organization and PostgreSQL full-text search
infrastructure

Purpose: Enable task categorization via flexible tagging system and prepare
database for instant semantic search with fuzzy matching fallback.

Output: Tag model with implicit m-n relation to tasks, tsvector column with GIN
index, pg_trgm extension enabled, DAL and Server Actions for tag operations.
</objective>

<execution_context>
@/Users/dansidanutz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dansidanutz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-task-organization-discovery/04-CONTEXT.md
@.planning/phases/04-task-organization-discovery/04-RESEARCH.md
@prisma/schema.prisma
@src/shared/lib/dal.ts
@src/app/actions/tasks.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Tag model and search infrastructure to Prisma schema</name>
  <files>prisma/schema.prisma</files>
  <action>
Add Tag model with implicit many-to-many relation to Task:

```prisma

model Tag {
  id        String   @id @default(cuid())
  name      String   @unique @db.VarChar(50)
  color     String?  @db.VarChar(7) // Hex color like #3b82f6
  userId    String   // Tags are per-user
  tasks     Task[]   // Implicit m-n relation
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, name]) // User can't have duplicate tag names
  @@index([userId])
  @@map("tags")
}

```yaml

Update Task model to include tags relation:

```prisma

model Task {
  // ... existing fields ...
  tags Tag[] // Implicit m-n relation (Prisma auto-generates _TaskToTag join table)
}

```

Update User model to include tags relation:

```prisma

model User {
  // ... existing fields ...
  tags Tag[]
}

```html

DO NOT add search_vector to schema.prisma - it must be added via raw SQL
migration because Prisma doesn't support generated columns or tsvector type
natively.
  </action>
  <verify>Run `npx prisma validate` - should succeed without errors</verify>
  <done>Tag model exists with implicit m-n to Task, userId foreign key, unique
  constraint on [userId, name]</done>
</task>

<task type="auto">
  <name>Task 2: Create migration with PostgreSQL extensions and search
  indexes</name>
  <files>prisma/migrations/XXX_add_tags_and_search/migration.sql</files>
  <action>
Run `npx prisma migrate dev --name add_tags_and_search --create-only` to
generate the base migration.

Then edit the generated migration.sql to ADD these SQL statements at the end:

```sql

-- Enable pg_trgm extension for fuzzy search
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- Add generated tsvector column for full-text search (weighted: title=A, description=B)
ALTER TABLE tasks
ADD COLUMN search_vector tsvector
GENERATED ALWAYS AS (
  setweight(to_tsvector('english', coalesce(title, '')), 'A') ||
  setweight(to_tsvector('english', coalesce(description, '')), 'B')
) STORED;

-- Create GIN index for fast full-text search
CREATE INDEX tasks_search_vector_idx ON tasks USING GIN(search_vector);

-- Create trigram indexes for fuzzy search fallback
CREATE INDEX tasks_title_trgm_idx ON tasks USING GIN(title gin_trgm_ops);
CREATE INDEX tasks_description_trgm_idx ON tasks USING GIN(description gin_trgm_ops);

```

Run `npx prisma migrate dev` to apply the migration.

IMPORTANT: After migration, run `npx prisma generate` to update the Prisma
client.

WHY generated column: Automatically keeps search_vector in sync with
title/description changes without triggers. Requires PostgreSQL 12+ (Railway
uses 15+).

WHY weighted search: Title matches (weight A) rank higher than description
matches (weight B) in search results.
  </action>
  <verify>Run `npx prisma db push --force-reset` if needed, then verify with:
  `npx prisma db execute --stdin <<< "SELECT column_name FROM
  information_schema.columns WHERE table_name = 'tasks' AND column_name =
  'search_vector';"` - should return search_vector</verify>
  <done>Migration applied successfully, search_vector column exists, GIN indexes
  created</done>
</task>

<task type="auto">
  <name>Task 3: Add DAL functions for tags and search</name>
  <files>src/shared/lib/dal.ts</files>
  <action>
Add these new DAL functions to the existing dal.ts:

```typescript

/**

 * Get all tags for a user

 */
export const getTagsByUser = cache(async (userId: string): Promise<Tag[]> => {
  try {

```
const tags = await prisma.tag.findMany({
  where: { userId },
  orderBy: { name: 'asc' }
})
return tags

```
  } catch (error) {

```
console.error('Error fetching user tags:', error)
return []

```
  }
})

/**

 * Full-text search tasks using PostgreSQL tsvector.
 * Falls back to fuzzy trigram search if no FTS matches.

 */
export const searchTasks = cache(async (
  userId: string,
  query: string
): Promise<(Task & { tags: Tag[], rank?: number })[]> => {
  if (!query.trim()) {

```
return []

```
  }

  try {

```
// First try full-text search
const ftsResults = await prisma.$queryRaw<(Task & { rank: number })[]>`
  SELECT id, title, description, status, "createdAt", "updatedAt", "userId",
         ts_rank(search_vector, websearch_to_tsquery('english', ${query})) as rank
  FROM tasks
  WHERE "userId" = ${userId}
    AND search_vector @@ websearch_to_tsquery('english', ${query})
  ORDER BY rank DESC, "createdAt" DESC
  LIMIT 50
`

// If FTS returns results, fetch with tags
if (ftsResults.length > 0) {
  const taskIds = ftsResults.map(r => r.id)
  const tasksWithTags = await prisma.task.findMany({
    where: { id: { in: taskIds } },
    include: { tags: true }
  })

  // Preserve FTS ranking order
  const taskMap = new Map(tasksWithTags.map(t => [t.id, t]))
  return ftsResults.map(r => ({
    ...taskMap.get(r.id)!,
    rank: r.rank
  }))
}

// Fallback to fuzzy trigram search
const fuzzyResults = await prisma.$queryRaw<Task[]>`
  SELECT id, title, description, status, "createdAt", "updatedAt", "userId"
  FROM tasks
  WHERE "userId" = ${userId}
    AND (
      title % ${query}
      OR description % ${query}
      OR title ILIKE ${'%' + query + '%'}
      OR description ILIKE ${'%' + query + '%'}
    )
  ORDER BY
    GREATEST(
      similarity(title, ${query}),
      COALESCE(similarity(description, ${query}), 0)
    ) DESC,
    "createdAt" DESC
  LIMIT 50
`

if (fuzzyResults.length > 0) {
  const taskIds = fuzzyResults.map(r => r.id)
  const tasksWithTags = await prisma.task.findMany({
    where: { id: { in: taskIds } },
    include: { tags: true }
  })
  const taskMap = new Map(tasksWithTags.map(t => [t.id, t]))
  return fuzzyResults.map(r => taskMap.get(r.id)!)
}

return []

```
  } catch (error) {

```
console.error('Error searching tasks:', error)
return []

```
  }
})

/**

 * Filter tasks by status, tags, and date range.
 * All filters are optional and combined with AND logic.

 */
export const filterTasks = cache(async (
  userId: string,
  filters: {

```
status?: TaskStatus[]
tagIds?: string[]
dateFrom?: Date
dateTo?: Date

```
  }
): Promise<(Task & { tags: Tag[] })[]> => {
  try {

```
const where: Prisma.TaskWhereInput = {
  userId,
  ...(filters.status?.length && { status: { in: filters.status } }),
  ...(filters.tagIds?.length && {
    tags: {
      some: { id: { in: filters.tagIds } }
    }
  }),
  ...(filters.dateFrom && { createdAt: { gte: filters.dateFrom } }),
  ...(filters.dateTo && { createdAt: { lte: filters.dateTo } }),
}

const tasks = await prisma.task.findMany({
  where,
  include: { tags: true },
  orderBy: [
    { status: 'asc' },
    { createdAt: 'desc' }
  ]
})

return tasks

```
  } catch (error) {

```
console.error('Error filtering tasks:', error)
return []

```
  }
})

/**

 * Get task with tags for display.

 */
export const getTaskWithTags = cache(async (
  taskId: string,
  userId: string
): Promise<(Task & { tags: Tag[] }) | null> => {
  try {

```
const task = await prisma.task.findFirst({
  where: { id: taskId, userId },
  include: { tags: true }
})
return task

```
  } catch (error) {

```
console.error('Error fetching task with tags:', error)
return null

```
  }
})

```yaml

Add necessary imports at the top:

```typescript

import { Task, TaskStatus, Tag, Prisma } from '@prisma/client'

```

  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>DAL functions getTagsByUser, searchTasks, filterTasks, getTaskWithTags
  exist and are typed correctly</done>
</task>

<task type="auto">
  <name>Task 4: Create Server Actions for tag management</name>
  <files>src/app/actions/tags.ts</files>
  <action>
Create new file `src/app/actions/tags.ts`:

```typescript

'use server'

import { revalidatePath } from 'next/cache'
import { z } from 'zod'

import { prisma } from '@/shared/lib/db'
import { getUser } from '@/shared/lib/dal'
import { trackEvent } from '@/shared/lib/analytics'

// Validation schemas
const CreateTagSchema = z.object({
  name: z.string().min(1, 'Tag name is required').max(50, 'Tag name too long'),
  color: z.string().regex(/^#[0-9A-Fa-f]{6}$/, 'Invalid color format').optional(),
})

const UpdateTaskTagsSchema = z.object({
  taskId: z.string().min(1),
  tagIds: z.array(z.string()),
})

type ActionResult<T = void> =
  | { success: true; data?: T }
  | { success: false; error: string }

/**

 * Create a new tag for the authenticated user

 */
export async function createTag(formData: FormData): Promise<ActionResult<{ tagId: string }>> {
  try {

```
const user = await getUser()
if (!user) {
  return { success: false, error: 'You must be logged in to create tags' }
}

const result = CreateTagSchema.safeParse({
  name: formData.get('name'),
  color: formData.get('color') || undefined,
})

if (!result.success) {
  return { success: false, error: result.error.issues[0].message }
}

const { name, color } = result.data

// Check for duplicate tag name for this user
const existing = await prisma.tag.findFirst({
  where: { userId: user.id, name: { equals: name, mode: 'insensitive' } }
})

if (existing) {
  return { success: false, error: 'A tag with this name already exists' }
}

const tag = await prisma.tag.create({
  data: {
    name,
    color: color || '#6b7280', // Default gray
    userId: user.id,
  },
})

trackEvent({
  type: 'tag_created',
  userId: user.id,
  properties: { tagId: tag.id, tagName: tag.name },
})

revalidatePath('/tasks')
return { success: true, data: { tagId: tag.id } }

```
  } catch (error) {

```
console.error('Create tag error:', error)
return { success: false, error: 'Failed to create tag' }

```
  }
}

/**

 * Delete a tag (removes from all tasks automatically via cascade)

 */
export async function deleteTag(tagId: string): Promise<ActionResult> {
  try {

```
const user = await getUser()
if (!user) {
  return { success: false, error: 'You must be logged in to delete tags' }
}

const tag = await prisma.tag.findFirst({
  where: { id: tagId, userId: user.id }
})

if (!tag) {
  return { success: false, error: 'Tag not found or access denied' }
}

await prisma.tag.delete({ where: { id: tagId } })

trackEvent({
  type: 'tag_deleted',
  userId: user.id,
  properties: { tagId, tagName: tag.name },
})

revalidatePath('/tasks')
return { success: true }

```
  } catch (error) {

```
console.error('Delete tag error:', error)
return { success: false, error: 'Failed to delete tag' }

```
  }
}

/**

 * Update tags for a task (set operation - replaces all existing tags)

 */
export async function updateTaskTags(
  taskId: string,
  tagIds: string[]
): Promise<ActionResult> {
  try {

```
const user = await getUser()
if (!user) {
  return { success: false, error: 'You must be logged in to update task tags' }
}

// Verify task ownership
const task = await prisma.task.findFirst({
  where: { id: taskId, userId: user.id }
})

if (!task) {
  return { success: false, error: 'Task not found or access denied' }
}

// Verify all tags belong to user
if (tagIds.length > 0) {
  const userTagCount = await prisma.tag.count({
    where: { id: { in: tagIds }, userId: user.id }
  })
  if (userTagCount !== tagIds.length) {
    return { success: false, error: 'One or more tags not found' }
  }
}

// Update task tags (set operation)
await prisma.task.update({
  where: { id: taskId },
  data: {
    tags: {
      set: tagIds.map(id => ({ id }))
    }
  }
})

trackEvent({
  type: 'task_tags_updated',
  userId: user.id,
  properties: { taskId, tagCount: tagIds.length },
})

revalidatePath('/tasks')
revalidatePath(`/tasks/${taskId}/edit`)
return { success: true }

```
  } catch (error) {

```
console.error('Update task tags error:', error)
return { success: false, error: 'Failed to update task tags' }

```
  }
}

/**

 * Add tag to task during task creation (creates tag if doesn't exist)

 */
export async function addTagToTask(
  taskId: string,
  tagName: string
): Promise<ActionResult<{ tagId: string }>> {
  try {

```
const user = await getUser()
if (!user) {
  return { success: false, error: 'You must be logged in' }
}

// Verify task ownership
const task = await prisma.task.findFirst({
  where: { id: taskId, userId: user.id }
})

if (!task) {
  return { success: false, error: 'Task not found or access denied' }
}

// Connect or create tag
const updatedTask = await prisma.task.update({
  where: { id: taskId },
  data: {
    tags: {
      connectOrCreate: {
        where: { userId_name: { userId: user.id, name: tagName } },
        create: { name: tagName, color: '#6b7280', userId: user.id }
      }
    }
  },
  include: { tags: true }
})

const addedTag = updatedTask.tags.find(t => t.name === tagName)

trackEvent({
  type: 'tag_added_to_task',
  userId: user.id,
  properties: { taskId, tagName },
})

revalidatePath('/tasks')
return { success: true, data: { tagId: addedTag?.id || '' } }

```
  } catch (error) {

```
console.error('Add tag to task error:', error)
return { success: false, error: 'Failed to add tag to task' }

```
  }
}

```html

  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>Server Actions createTag, deleteTag, updateTaskTags, addTagToTask exist
  with proper validation and analytics</done>
</task>

</tasks>

<verification>

1. Run `npx prisma validate` - schema is valid
2. Run `npx prisma migrate dev` - migrations applied
3. Run `npx tsc --noEmit` - TypeScript compiles
4. Check database: `npx prisma studio` - verify tags table and _TaskToTag join
table exist
5. Verify search_vector column exists in tasks table

</verification>

<success_criteria>

- Tag model exists with implicit m-n to Task
- search_vector tsvector column exists on tasks table (generated)
- GIN indexes exist for search_vector, title trigrams, description trigrams
- pg_trgm extension is enabled
- DAL functions handle full-text search with fuzzy fallback
- Server Actions for tag CRUD operations work
- All TypeScript types are correct

</success_criteria>

<output>
After completion, create
`.planning/phases/04-task-organization-discovery/04-01-SUMMARY.md`
</output>
