---
phase: 04-task-organization-discovery
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - package.json
  - src/app/(app)/tasks/search-params.ts
  - src/app/(app)/tasks/page.tsx
  - src/shared/components/TaskSearchBar.tsx
  - src/shared/components/TaskFilters.tsx
  - src/app/actions/search.ts
autonomous: true

must_haves:
  truths:
    - "Search input exists on tasks page"
    - "Typing in search filters tasks instantly (after debounce)"
    - "Filter state is stored in URL params"
    - "Status filter dropdown exists and filters tasks"
    - "Clear filters button resets all filters"
  artifacts:
    - path: "src/app/(app)/tasks/search-params.ts"
      provides: "nuqs parser definitions for URL state"
      exports: ["taskSearchParams"]
    - path: "src/shared/components/TaskSearchBar.tsx"
      provides: "Debounced search input component"
      min_lines: 40
    - path: "src/shared/components/TaskFilters.tsx"
      provides: "Filter sidebar with status and tag filters"
      min_lines: 60
    - path: "src/app/actions/search.ts"
      provides: "Server Action for search"
      exports: ["searchTasksAction", "filterTasksAction"]
  key_links:
    - from: "src/shared/components/TaskSearchBar.tsx"
      to: "src/app/actions/search.ts"
      via: "Server Action call on debounced input"
      pattern: "searchTasksAction"
    - from: "src/app/(app)/tasks/page.tsx"
      to: "nuqs"
      via: "useQueryStates hook"
      pattern: "useQueryStates"
---

<objective>
Build search and filter UI components with URL-based state management

Purpose: Enable users to search tasks by title/description with instant feedback, filter by status and tags, with filter state persisted in URL for shareability.

Output: TaskSearchBar with debounced input, TaskFilters sidebar, nuqs-powered URL state, Server Actions for search and filter operations.
</objective>

<execution_context>
@/Users/dansidanutz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dansidanutz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-task-organization-discovery/04-CONTEXT.md
@.planning/phases/04-task-organization-discovery/04-RESEARCH.md
@.planning/phases/04-task-organization-discovery/04-01-SUMMARY.md
@src/app/(app)/tasks/page.tsx
@src/shared/lib/dal.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install nuqs and use-debounce libraries</name>
  <files>package.json</files>
  <action>
Install the required npm packages:

```bash
npm install nuqs use-debounce
```

WHY nuqs: Type-safe URL state management, like useState but persisted in URL. Enables shareable/bookmarkable filter states. 6kB bundle size.

WHY use-debounce: Prevents excessive database queries during typing. 300ms delay is Next.js recommended default.

Verify both packages are in package.json dependencies after install.
  </action>
  <verify>Run `npm ls nuqs use-debounce` - both packages should be listed</verify>
  <done>nuqs and use-debounce installed and listed in package.json</done>
</task>

<task type="auto">
  <name>Task 2: Create search params parser definitions</name>
  <files>src/app/(app)/tasks/search-params.ts</files>
  <action>
Create new file with nuqs parser definitions:

```typescript
import {
  parseAsString,
  parseAsArrayOf,
  parseAsStringEnum,
  createSearchParamsCache,
} from 'nuqs/server'

// Task status values matching Prisma enum
const statusValues = ['TODO', 'IN_PROGRESS', 'DONE'] as const

// Parser definitions for task list URL params
export const taskSearchParams = {
  // Search query
  q: parseAsString.withDefault(''),

  // Status filter (multiple selection)
  status: parseAsArrayOf(
    parseAsStringEnum(statusValues)
  ).withDefault([]),

  // Tag filter (multiple selection by tag ID)
  tags: parseAsArrayOf(parseAsString).withDefault([]),

  // Sort options
  sortBy: parseAsStringEnum(['createdAt', 'updatedAt', 'title'] as const)
    .withDefault('createdAt'),
  sortOrder: parseAsStringEnum(['asc', 'desc'] as const)
    .withDefault('desc'),
}

// Server-side cache for search params (Next.js 15 pattern)
export const searchParamsCache = createSearchParamsCache(taskSearchParams)

// Type helper for filter state
export type TaskFilters = {
  q: string
  status: typeof statusValues[number][]
  tags: string[]
  sortBy: 'createdAt' | 'updatedAt' | 'title'
  sortOrder: 'asc' | 'desc'
}
```

WHY createSearchParamsCache: Next.js 15 requires server-side caching of search params for proper Server Component integration.

WHY withDefault: Ensures type safety - values are never null/undefined.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>search-params.ts exports taskSearchParams, searchParamsCache, and TaskFilters type</done>
</task>

<task type="auto">
  <name>Task 3: Create Server Actions for search and filter operations</name>
  <files>src/app/actions/search.ts</files>
  <action>
Create new file `src/app/actions/search.ts`:

```typescript
'use server'

import { searchTasks, filterTasks, getTagsByUser } from '@/shared/lib/dal'
import { getUser } from '@/shared/lib/dal'
import { trackEvent } from '@/shared/lib/analytics'
import { TaskStatus, Task, Tag } from '@prisma/client'

type TaskWithTags = Task & { tags: Tag[] }

type SearchResult = {
  success: true
  tasks: TaskWithTags[]
  resultCount: number
} | {
  success: false
  error: string
}

/**
 * Search tasks by query string using full-text search
 */
export async function searchTasksAction(query: string): Promise<SearchResult> {
  try {
    const user = await getUser()
    if (!user) {
      return { success: false, error: 'Not authenticated' }
    }

    const tasks = await searchTasks(user.id, query)

    // Track search analytics (non-blocking)
    if (query.trim()) {
      trackEvent({
        type: 'search_performed',
        userId: user.id,
        properties: {
          query,
          resultCount: tasks.length,
        },
      })
    }

    return {
      success: true,
      tasks,
      resultCount: tasks.length,
    }
  } catch (error) {
    console.error('Search error:', error)
    return { success: false, error: 'Search failed' }
  }
}

/**
 * Filter tasks by status, tags, and date range
 */
export async function filterTasksAction(filters: {
  status?: TaskStatus[]
  tagIds?: string[]
  dateFrom?: string
  dateTo?: string
}): Promise<SearchResult> {
  try {
    const user = await getUser()
    if (!user) {
      return { success: false, error: 'Not authenticated' }
    }

    const tasks = await filterTasks(user.id, {
      status: filters.status,
      tagIds: filters.tagIds,
      dateFrom: filters.dateFrom ? new Date(filters.dateFrom) : undefined,
      dateTo: filters.dateTo ? new Date(filters.dateTo) : undefined,
    })

    // Track filter analytics (non-blocking)
    const hasFilters = filters.status?.length || filters.tagIds?.length || filters.dateFrom || filters.dateTo
    if (hasFilters) {
      trackEvent({
        type: 'filter_applied',
        userId: user.id,
        properties: {
          statusCount: filters.status?.length || 0,
          tagCount: filters.tagIds?.length || 0,
          hasDateRange: !!(filters.dateFrom || filters.dateTo),
          resultCount: tasks.length,
        },
      })
    }

    return {
      success: true,
      tasks,
      resultCount: tasks.length,
    }
  } catch (error) {
    console.error('Filter error:', error)
    return { success: false, error: 'Filter failed' }
  }
}

/**
 * Get user's tags for filter dropdown
 */
export async function getTagsForFilterAction(): Promise<{
  success: true
  tags: Tag[]
} | {
  success: false
  error: string
}> {
  try {
    const user = await getUser()
    if (!user) {
      return { success: false, error: 'Not authenticated' }
    }

    const tags = await getTagsByUser(user.id)
    return { success: true, tags }
  } catch (error) {
    console.error('Get tags error:', error)
    return { success: false, error: 'Failed to load tags' }
  }
}
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Server Actions searchTasksAction, filterTasksAction, getTagsForFilterAction exist with proper typing</done>
</task>

<task type="auto">
  <name>Task 4: Create TaskSearchBar component with debounced input</name>
  <files>src/shared/components/TaskSearchBar.tsx</files>
  <action>
Create new file `src/shared/components/TaskSearchBar.tsx`:

```typescript
'use client'

import { useState, useCallback } from 'react'
import { useDebouncedCallback } from 'use-debounce'
import { MagnifyingGlassIcon, XMarkIcon } from '@heroicons/react/24/outline'

type TaskSearchBarProps = {
  value: string
  onChange: (value: string) => void
  onSearch: (query: string) => void
  isSearching?: boolean
  resultCount?: number
}

export function TaskSearchBar({
  value,
  onChange,
  onSearch,
  isSearching = false,
  resultCount,
}: TaskSearchBarProps) {
  const [localValue, setLocalValue] = useState(value)

  // Debounce the search callback (300ms per Next.js recommendation)
  const debouncedSearch = useDebouncedCallback((query: string) => {
    onSearch(query)
  }, 300)

  const handleChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value
    setLocalValue(newValue)
    onChange(newValue)
    debouncedSearch(newValue)
  }, [onChange, debouncedSearch])

  const handleClear = useCallback(() => {
    setLocalValue('')
    onChange('')
    onSearch('')
  }, [onChange, onSearch])

  return (
    <div className="relative">
      {/* Search icon */}
      <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
        <MagnifyingGlassIcon
          className={`h-5 w-5 ${isSearching ? 'text-blue-500 animate-pulse' : 'text-gray-400'}`}
        />
      </div>

      {/* Search input */}
      <input
        type="search"
        value={localValue}
        onChange={handleChange}
        placeholder="Search tasks..."
        className="
          block w-full
          pl-10 pr-10 py-2
          border border-gray-300 dark:border-gray-600
          rounded-lg
          bg-white dark:bg-gray-800
          text-gray-900 dark:text-gray-100
          placeholder-gray-500 dark:placeholder-gray-400
          focus:ring-2 focus:ring-blue-500 focus:border-transparent
          text-sm
        "
      />

      {/* Clear button (shown when there's input) */}
      {localValue && (
        <button
          type="button"
          onClick={handleClear}
          className="
            absolute inset-y-0 right-0 pr-3
            flex items-center
            text-gray-400 hover:text-gray-600
            dark:hover:text-gray-300
          "
        >
          <XMarkIcon className="h-5 w-5" />
        </button>
      )}

      {/* Result count indicator */}
      {localValue && resultCount !== undefined && !isSearching && (
        <div className="absolute -bottom-6 left-0 text-xs text-gray-500 dark:text-gray-400">
          {resultCount === 0 ? 'No results' : `${resultCount} result${resultCount !== 1 ? 's' : ''}`}
        </div>
      )}
    </div>
  )
}
```

Also install heroicons if not already installed:
```bash
npm install @heroicons/react
```
  </action>
  <verify>Component file exists and TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>TaskSearchBar component with debounced input, clear button, and result count display</done>
</task>

<task type="auto">
  <name>Task 5: Create TaskFilters sidebar component</name>
  <files>src/shared/components/TaskFilters.tsx</files>
  <action>
Create new file `src/shared/components/TaskFilters.tsx`:

```typescript
'use client'

import { useCallback } from 'react'
import { FunnelIcon, XMarkIcon } from '@heroicons/react/24/outline'
import { Tag } from '@prisma/client'

type TaskStatus = 'TODO' | 'IN_PROGRESS' | 'DONE'

type TaskFiltersProps = {
  selectedStatuses: TaskStatus[]
  selectedTags: string[]
  availableTags: Tag[]
  onStatusChange: (statuses: TaskStatus[]) => void
  onTagChange: (tagIds: string[]) => void
  onClearFilters: () => void
}

const statusOptions: { value: TaskStatus; label: string; color: string }[] = [
  { value: 'TODO', label: 'To Do', color: 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200' },
  { value: 'IN_PROGRESS', label: 'In Progress', color: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200' },
  { value: 'DONE', label: 'Done', color: 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200' },
]

export function TaskFilters({
  selectedStatuses,
  selectedTags,
  availableTags,
  onStatusChange,
  onTagChange,
  onClearFilters,
}: TaskFiltersProps) {
  const hasActiveFilters = selectedStatuses.length > 0 || selectedTags.length > 0

  const toggleStatus = useCallback((status: TaskStatus) => {
    if (selectedStatuses.includes(status)) {
      onStatusChange(selectedStatuses.filter(s => s !== status))
    } else {
      onStatusChange([...selectedStatuses, status])
    }
  }, [selectedStatuses, onStatusChange])

  const toggleTag = useCallback((tagId: string) => {
    if (selectedTags.includes(tagId)) {
      onTagChange(selectedTags.filter(t => t !== tagId))
    } else {
      onTagChange([...selectedTags, tagId])
    }
  }, [selectedTags, onTagChange])

  return (
    <div className="space-y-6">
      {/* Header with clear button */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2 text-sm font-medium text-gray-700 dark:text-gray-300">
          <FunnelIcon className="h-4 w-4" />
          Filters
        </div>
        {hasActiveFilters && (
          <button
            onClick={onClearFilters}
            className="
              text-xs text-gray-500 hover:text-gray-700
              dark:text-gray-400 dark:hover:text-gray-200
              flex items-center gap-1
            "
          >
            <XMarkIcon className="h-3 w-3" />
            Clear all
          </button>
        )}
      </div>

      {/* Status filter */}
      <div>
        <h3 className="text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider mb-2">
          Status
        </h3>
        <div className="space-y-2">
          {statusOptions.map((option) => (
            <label
              key={option.value}
              className="flex items-center gap-2 cursor-pointer group"
            >
              <input
                type="checkbox"
                checked={selectedStatuses.includes(option.value)}
                onChange={() => toggleStatus(option.value)}
                className="
                  h-4 w-4 rounded
                  border-gray-300 dark:border-gray-600
                  text-blue-600
                  focus:ring-blue-500
                "
              />
              <span className={`
                text-sm px-2 py-0.5 rounded-full
                ${selectedStatuses.includes(option.value) ? option.color : 'text-gray-600 dark:text-gray-400'}
                group-hover:opacity-80
              `}>
                {option.label}
              </span>
            </label>
          ))}
        </div>
      </div>

      {/* Tag filter */}
      {availableTags.length > 0 && (
        <div>
          <h3 className="text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider mb-2">
            Tags
          </h3>
          <div className="space-y-2 max-h-48 overflow-y-auto">
            {availableTags.map((tag) => (
              <label
                key={tag.id}
                className="flex items-center gap-2 cursor-pointer group"
              >
                <input
                  type="checkbox"
                  checked={selectedTags.includes(tag.id)}
                  onChange={() => toggleTag(tag.id)}
                  className="
                    h-4 w-4 rounded
                    border-gray-300 dark:border-gray-600
                    text-blue-600
                    focus:ring-blue-500
                  "
                />
                <span className="flex items-center gap-1.5 text-sm text-gray-600 dark:text-gray-400 group-hover:text-gray-900 dark:group-hover:text-gray-200">
                  <span
                    className="w-3 h-3 rounded-full flex-shrink-0"
                    style={{ backgroundColor: tag.color || '#6b7280' }}
                  />
                  {tag.name}
                </span>
              </label>
            ))}
          </div>
        </div>
      )}

      {/* Empty state when no tags */}
      {availableTags.length === 0 && (
        <div className="text-xs text-gray-500 dark:text-gray-400 italic">
          No tags yet. Create tags when editing tasks.
        </div>
      )}
    </div>
  )
}
```
  </action>
  <verify>Component file exists and TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>TaskFilters component with status checkboxes, tag checkboxes, and clear all button</done>
</task>

<task type="auto">
  <name>Task 6: Update tasks page with search and filter integration</name>
  <files>src/app/(app)/tasks/page.tsx</files>
  <action>
Rewrite the tasks page to integrate search and filters with nuqs URL state:

```typescript
import { Suspense } from 'react'
import Link from 'next/link'
import { searchParamsCache, taskSearchParams } from './search-params'
import { TaskListWithFilters } from '@/shared/components/TaskListWithFilters'

// Loading skeleton
function TaskListSkeleton() {
  return (
    <div className="space-y-8 animate-pulse">
      {[1, 2, 3].map((section) => (
        <div key={section}>
          <div className="h-7 bg-gray-200 dark:bg-gray-700 rounded w-32 mb-4" />
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {[1, 2, 3].map((card) => (
              <div
                key={card}
                className="p-4 bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700"
              >
                <div className="h-6 bg-gray-200 dark:bg-gray-700 rounded w-3/4 mb-3" />
                <div className="space-y-2 mb-4">
                  <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded w-full" />
                  <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded w-5/6" />
                </div>
                <div className="flex items-center justify-between">
                  <div className="h-8 bg-gray-200 dark:bg-gray-700 rounded w-24" />
                  <div className="h-8 bg-gray-200 dark:bg-gray-700 rounded w-16" />
                </div>
              </div>
            ))}
          </div>
        </div>
      ))}
    </div>
  )
}

type PageProps = {
  searchParams: Promise<Record<string, string | string[] | undefined>>
}

export default async function TasksPage({ searchParams }: PageProps) {
  // Parse search params on server using nuqs cache
  const params = await searchParams
  const { q, status, tags, sortBy, sortOrder } = searchParamsCache.parse(params)

  return (
    <div className="flex gap-6">
      {/* Main content area */}
      <div className="flex-1 min-w-0">
        {/* Page header */}
        <div className="flex items-center justify-between mb-6">
          <h1 className="text-3xl font-bold text-gray-900 dark:text-white">
            My Tasks
          </h1>
          <Link
            href="/tasks/new"
            className="
              inline-flex items-center justify-center
              px-4 py-2
              bg-blue-600 text-white
              rounded-md font-medium
              hover:bg-blue-700
              focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500
              dark:bg-blue-500 dark:hover:bg-blue-600
              transition-colors
            "
          >
            <svg className="w-5 h-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
            </svg>
            New Task
          </Link>
        </div>

        {/* Task list with search/filter integration */}
        <Suspense fallback={<TaskListSkeleton />}>
          <TaskListWithFilters
            initialQuery={q}
            initialStatuses={status}
            initialTags={tags}
            sortBy={sortBy}
            sortOrder={sortOrder}
          />
        </Suspense>
      </div>
    </div>
  )
}
```

This is a partial update - we need to create the TaskListWithFilters component in the next plan that combines all the pieces together.

For now, update the page to use the search params cache to parse URL params server-side.
  </action>
  <verify>Page renders without errors: `npm run dev` and visit /tasks</verify>
  <done>Tasks page parses URL search params using nuqs searchParamsCache</done>
</task>

</tasks>

<verification>
1. Run `npm ls nuqs use-debounce @heroicons/react` - all packages installed
2. Run `npx tsc --noEmit` - TypeScript compiles without errors
3. Run `npm run dev` - development server starts
4. Visit /tasks - page loads (may have rendering issues until Plan 03 completes)
5. Verify search-params.ts exports are correct
</verification>

<success_criteria>
- nuqs and use-debounce installed
- TaskSearchBar component exists with debounced input
- TaskFilters component exists with status/tag checkboxes
- Server Actions for search and filter exist
- search-params.ts defines URL state parsers
- Tasks page integrates with nuqs for URL state
</success_criteria>

<output>
After completion, create `.planning/phases/04-task-organization-discovery/04-02-SUMMARY.md`
</output>
