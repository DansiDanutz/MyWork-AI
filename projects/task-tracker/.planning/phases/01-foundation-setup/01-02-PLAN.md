---
phase: 01-foundation-setup
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:

  - package.json
  - prisma/schema.prisma
  - src/shared/lib/db/prisma.ts
  - src/shared/lib/env.ts
  - src/app/api/health/route.ts
  - .env
  - .env.example

autonomous: true

must_haves:
  truths:

```
- "Database connection succeeds with Prisma client"
- "Environment variables are validated at startup"
- "Health check endpoint returns database status"
- "Prisma migrations can be created and applied"

```
  artifacts:

```
- path: "prisma/schema.prisma"

  provides: "Database schema definition"
  contains: "datasource db"

- path: "src/shared/lib/db/prisma.ts"

  provides: "Prisma singleton client"
  contains: "globalForPrisma"

- path: "src/shared/lib/env.ts"

  provides: "Environment variable validation"
  contains: "envSchema"

- path: "src/app/api/health/route.ts"

  provides: "Health check API endpoint"
  exports: ["GET"]

- path: ".env.example"

  provides: "Environment variable template"
  contains: "DATABASE_URL"

```
  key_links:

```
- from: "src/app/api/health/route.ts"

  to: "prisma"
  via: "import and query"
  pattern: "prisma\\.\\$queryRaw"

- from: "src/shared/lib/db/prisma.ts"

  to: "@prisma/client"
  via: "import PrismaClient"
  pattern: "import.*PrismaClient"

- from: "src/shared/lib/env.ts"

  to: "process.env"
  via: "Zod validation"
  pattern: "envSchema\\.parse"

```
---

<objective>
Set up Prisma ORM with PostgreSQL, implement environment variable validation,
and create a health check endpoint to verify the foundation.

Purpose: Establish database connectivity and configuration patterns that all
subsequent phases depend on. The Prisma singleton pattern prevents connection
pool exhaustion during development, and environment validation catches
configuration errors at startup.

Output: Working database connection, validated environment variables, and a
health check endpoint that confirms the entire foundation is operational.
</objective>

<execution_context>
@/Users/dansidanutz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dansidanutz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-setup/01-RESEARCH.md
@.planning/phases/01-foundation-setup/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Setup Prisma and Database</name>
  <files>

```
package.json
prisma/schema.prisma
src/shared/lib/db/prisma.ts
src/shared/lib/db/index.ts

```
  </files>
  <action>

```
1. Install Prisma dependencies:

   ```bash
   npm install -D prisma tsx
   npm install @prisma/client

```

```yaml

```
2. Initialize Prisma:

   ```bash
   npx prisma init

   ```

   This creates prisma/schema.prisma and updates .env with DATABASE_URL
   placeholder.

3. Update prisma/schema.prisma with PostgreSQL configuration:

   ```prisma

   generator client {
     provider = "prisma-client-js"
   }

   datasource db {
     provider = "postgresql"
     url      = env("DATABASE_URL")
   }

   // Placeholder model for initial migration
   // Will be replaced with actual models in Phase 2+
   model HealthCheck {
     id        String   @id @default(cuid())
     checkedAt DateTime @default(now())
   }

```

```yaml

```
4. Create Prisma singleton client (src/shared/lib/db/prisma.ts):

   ```typescript

   import { PrismaClient } from '@prisma/client'

   const globalForPrisma = globalThis as unknown as {
     prisma: PrismaClient | undefined
   }

   export const prisma = globalForPrisma.prisma ?? new PrismaClient({
     log: process.env.NODE_ENV === 'development'
       ? ['query', 'error', 'warn']
       : ['error'],
   })

   if (process.env.NODE_ENV !== 'production') {
     globalForPrisma.prisma = prisma
   }

   ```

5. Create public export (src/shared/lib/db/index.ts):

   ```typescript

   export { prisma } from './prisma'

```

```yaml

```
6. Update .env with a local PostgreSQL connection string:

   ```
   DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tasktracker?schema=public"

```

```yaml

```
7. Create and apply initial migration:

   ```bash
   npx prisma migrate dev --name init

   ```

NOTE: This requires PostgreSQL running locally. If not available, the
verification will fail and user will need to start PostgreSQL first.

```
  </action>
  <verify>

```
1. Run `npm list @prisma/client` - should show installed version
2. Run `cat prisma/schema.prisma` - should show PostgreSQL datasource
3. Run `cat src/shared/lib/db/prisma.ts` - should show globalForPrisma
pattern
4. Run `npx prisma db push` - should succeed without errors (requires
running PostgreSQL)
5. Run `npx prisma studio` - should open browser and show HealthCheck table

```
  </verify>
  <done>

```
Prisma is configured with PostgreSQL, singleton client pattern is
implemented, and database connection succeeds.

```
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Environment Validation</name>
  <files>

```
package.json
src/shared/lib/env.ts
.env
.env.example

```
  </files>
  <action>

```
1. Install Zod for schema validation:

   ```bash
   npm install zod

```

```yaml

```
2. Create environment validation (src/shared/lib/env.ts):

   ```typescript

   import { z } from 'zod'

   const envSchema = z.object({
     // Database
     DATABASE_URL: z.string().url().startsWith('postgresql://'),

     // Node environment
     NODE_ENV: z.enum(['development', 'test', 'production']).default('development'),

     // App URL (client-exposed)
     NEXT_PUBLIC_APP_URL: z.string().url().default('http://localhost:3000'),
   })

   // Validate at import time - fails fast if env is misconfigured
   const parsed = envSchema.safeParse(process.env)

   if (!parsed.success) {
     console.error('Invalid environment variables:')
     console.error(parsed.error.flatten().fieldErrors)
     throw new Error('Invalid environment configuration')
   }

   export const env = parsed.data

   ```

3. Create .env.example template (committed to git):

```
```markdown

```
   # Database

   DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tasktracker?schema=public"

   # Environment

   NODE_ENV="development"

   # App URL (client-exposed)

   NEXT_PUBLIC_APP_URL="http://localhost:3000"

   ```

4. Update .env with all required variables:

```

```yaml

```
   DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tasktracker?schema=public"
   NODE_ENV="development"
   NEXT_PUBLIC_APP_URL="http://localhost:3000"

   ```

5. Add .env.example to git (it's safe, contains no secrets):

   ```bash
   git add .env.example

```

```python

```
6. Verify .env is in .gitignore (should be by default from create-next-app).

```
  </action>
  <verify>

```
1. Run `npm list zod` - should show installed version
2. Run `cat src/shared/lib/env.ts` - should show envSchema with Zod
validation
3. Run `cat .env.example` - should show all required env vars
4. Run `npx tsx -e "import { env } from './src/shared/lib/env';
console.log(env)"` - should print validated env vars

```
  </verify>
  <done>

```
Environment variables are validated with Zod at startup, .env.example
template exists for onboarding, and misconfigured environments fail fast
with clear error messages.

```
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Health Check Endpoint</name>
  <files>

```
src/app/api/health/route.ts

```
  </files>
  <action>

```
Create health check API endpoint (src/app/api/health/route.ts):

```typescript

import { prisma } from '@/shared/lib/db'
import { env } from '@/shared/lib/env'
import { NextResponse } from 'next/server'

export async function GET() {
  const checks = {
    timestamp: new Date().toISOString(),
    status: 'ok' as 'ok' | 'error',
    environment: env.NODE_ENV,
    checks: {
      database: { status: 'pending' as 'ok' | 'error', message: '' },
      environment: { status: 'ok' as 'ok' | 'error', message: 'Validated' },
    },
  }

  // Check database connection
  try {
    await prisma.$queryRaw`SELECT 1`
    checks.checks.database = { status: 'ok', message: 'Connected' }
  } catch (error) {
    checks.status = 'error'
    checks.checks.database = {
      status: 'error',
      message: error instanceof Error ? error.message : 'Connection failed',
    }
  }

  const statusCode = checks.status === 'ok' ? 200 : 503

  return NextResponse.json(checks, { status: statusCode })
}

```

This endpoint:

- Validates environment loaded correctly (Zod validation happens on import)
- Tests database connectivity with a simple query
- Returns structured health status for monitoring
- Uses proper HTTP status codes (200 OK, 503 Service Unavailable)

```
  </action>
  <verify>

```
1. Start dev server: `npm run dev`
2. Visit <http://localhost:3000/api/health> - should return JSON with status
"ok"
3. Expected response:

   ```json
   {
     "timestamp": "2026-01-24T...",
     "status": "ok",
     "environment": "development",
     "checks": {
       "database": { "status": "ok", "message": "Connected" },
       "environment": { "status": "ok", "message": "Validated" }
     }
   }

```

```yaml

```
4. Run `curl <http://localhost:3000/api/health`> - should return same JSON

```
  </verify>
  <done>

```
Health check endpoint at /api/health returns database and environment
status, confirming the entire Phase 1 foundation is operational.

```
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify the complete Phase 1 foundation:

1. **Database Connection:**

   ```bash
   npx prisma db push

   # Should succeed without errors

   ```

2. **Environment Validation:**

   ```bash

   # Temporarily break .env to test validation

   echo "DATABASE_URL=invalid" > .env.test
   NODE_ENV=test npx tsx -e "import { env } from './src/shared/lib/env'" 2>&1 | head -5

   # Should show validation error, not crash silently

```yaml

3. **Health Check Endpoint:**

   ```bash
   npm run dev &
   sleep 3
   curl -s http://localhost:3000/api/health | jq .

   # Should return status: "ok" with all checks passing

   ```

4. **Full Build:**

   ```bash
   npm run build

   # Should complete without TypeScript errors

```yaml

5. **Project Structure:**

   ```bash
   tree src/shared/lib/ -L 2

   # Should show:

   # src/shared/lib/

   # ├── db/

   # │   ├── index.ts

   # │   └── prisma.ts

   # └── env.ts

   ```

</verification>

<success_criteria>

- Prisma ORM installed and configured for PostgreSQL
- Prisma singleton pattern prevents connection pool exhaustion
- Initial migration created and applied successfully
- Environment variables validated with Zod at startup
- .env.example template committed for team onboarding
- Health check endpoint returns database and environment status
- All TypeScript compilation succeeds
- Development server runs without errors

</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-setup/01-02-SUMMARY.md`
</output>
