---
phase: 01-foundation-setup
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:

  - package.json
  - prisma/schema.prisma
  - src/shared/lib/db/prisma.ts
  - src/shared/lib/env.ts
  - src/app/api/health/route.ts
  - .env
  - .env.example

autonomous: true

must_haves:
  truths:

```markdown

- "Database connection succeeds with Prisma client"
- "Environment variables are validated at startup"
- "Health check endpoint returns database status"
- "Prisma migrations can be created and applied"

```yaml

  artifacts:

```yaml

- path: "prisma/schema.prisma"

  provides: "Database schema definition"
  contains: "datasource db"

- path: "src/shared/lib/db/prisma.ts"

  provides: "Prisma singleton client"
  contains: "globalForPrisma"

- path: "src/shared/lib/env.ts"

  provides: "Environment variable validation"
  contains: "envSchema"

- path: "src/app/api/health/route.ts"

  provides: "Health check API endpoint"
  exports: ["GET"]

- path: ".env.example"

  provides: "Environment variable template"
  contains: "DATABASE_URL"

```yaml

  key_links:

```yaml

- from: "src/app/api/health/route.ts"

  to: "prisma"
  via: "import and query"
  pattern: "prisma\\.\\$queryRaw"

- from: "src/shared/lib/db/prisma.ts"

  to: "@prisma/client"
  via: "import PrismaClient"
  pattern: "import.*PrismaClient"

- from: "src/shared/lib/env.ts"

  to: "process.env"
  via: "Zod validation"
  pattern: "envSchema\\.parse"

```html

---

<objective>
Set up Prisma ORM with PostgreSQL, implement environment variable validation,
and create a health check endpoint to verify the foundation.

Purpose: Establish database connectivity and configuration patterns that all
subsequent phases depend on. The Prisma singleton pattern prevents connection
pool exhaustion during development, and environment validation catches
configuration errors at startup.

Output: Working database connection, validated environment variables, and a
health check endpoint that confirms the entire foundation is operational.
</objective>

<execution_context>
@/Users/dansidanutz/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dansidanutz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-setup/01-RESEARCH.md
@.planning/phases/01-foundation-setup/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Setup Prisma and Database</name>
  <files>

```text
package.json
prisma/schema.prisma
src/shared/lib/db/prisma.ts
src/shared/lib/db/index.ts

```

  </files>
  <action>

```yaml

1. Install Prisma dependencies:

   ```bash

   npm install -D prisma tsx
   npm install @prisma/client

```yaml

```yaml

```yaml

2. Initialize Prisma:

   ```bash

   npx prisma init

```yaml

   This creates prisma/schema.prisma and updates .env with DATABASE_URL
   placeholder.

3. Update prisma/schema.prisma with PostgreSQL configuration:

   ```prisma

   generator client {

```text
 provider = "prisma-client-js"

```

   }

   datasource db {

```text
 provider = "postgresql"
 url      = env("DATABASE_URL")

```text

   }

   // Placeholder model for initial migration
   // Will be replaced with actual models in Phase 2+
   model HealthCheck {

```text
 id        String   @id @default(cuid())
 checkedAt DateTime @default(now())

```

   }

```text

```yaml

```yaml

4. Create Prisma singleton client (src/shared/lib/db/prisma.ts):

   ```typescript

   import { PrismaClient } from '@prisma/client'

   const globalForPrisma = globalThis as unknown as {

```yaml
 prisma: PrismaClient | undefined

```javascript

   }

   export const prisma = globalForPrisma.prisma ?? new PrismaClient({

```
 log: process.env.NODE_ENV === 'development'
   ? ['query', 'error', 'warn']
   : ['error'],

```text

   })

   if (process.env.NODE_ENV !== 'production') {

```yaml
 globalForPrisma.prisma = prisma

```yaml

   }

```yaml

5. Create public export (src/shared/lib/db/index.ts):

   ```typescript

   export { prisma } from './prisma'

```

```yaml

```yaml

6. Update .env with a local PostgreSQL connection string:

```yaml

   DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tasktracker?schema=public"

```text

```yaml

```yaml

7. Create and apply initial migration:

   ```bash

   npx prisma migrate dev --name init

```yaml

NOTE: This requires PostgreSQL running locally. If not available, the
verification will fail and user will need to start PostgreSQL first.

```html

  </action>
  <verify>

```markdown

1. Run `npm list @prisma/client` - should show installed version
2. Run `cat prisma/schema.prisma` - should show PostgreSQL datasource
3. Run `cat src/shared/lib/db/prisma.ts` - should show globalForPrisma

pattern

4. Run `npx prisma db push` - should succeed without errors (requires

running PostgreSQL)

5. Run `npx prisma studio` - should open browser and show HealthCheck table

```

  </verify>
  <done>

```text
Prisma is configured with PostgreSQL, singleton client pattern is
implemented, and database connection succeeds.

```html

  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Environment Validation</name>
  <files>

```text
package.json
src/shared/lib/env.ts
.env
.env.example

```html

  </files>
  <action>

```yaml

1. Install Zod for schema validation:

   ```bash

   npm install zod

```yaml

```yaml

```yaml

2. Create environment validation (src/shared/lib/env.ts):

   ```typescript

   import { z } from 'zod'

   const envSchema = z.object({

```
 // Database
 DATABASE_URL: z.string().url().startsWith('postgresql://'),

 // Node environment
 NODE_ENV: z.enum(['development', 'test',
 'production']).default('development'),

 // App URL (client-exposed)
 NEXT_PUBLIC_APP_URL: z.string().url().default('<http://localhost:3000'>),

```python

   })

   // Validate at import time - fails fast if env is misconfigured
   const parsed = envSchema.safeParse(process.env)

   if (!parsed.success) {

```yaml
 console.error('Invalid environment variables:')
 console.error(parsed.error.flatten().fieldErrors)
 throw new Error('Invalid environment configuration')

```javascript

   }

   export const env = parsed.data

   ```

3. Create .env.example template (committed to git):

```text

```markdown

```markdown

   # Database

   DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tasktracker?schema=public"

   # Environment

   NODE_ENV="development"

   # App URL (client-exposed)

   NEXT_PUBLIC_APP_URL="<http://localhost:3000">

```yaml

4. Update .env with all required variables:

```yaml

```yaml

```yaml

   DATABASE_URL="postgresql://postgres:postgres@localhost:5432/tasktracker?schema=public"
   NODE_ENV="development"
   NEXT_PUBLIC_APP_URL="<http://localhost:3000">

```yaml

5. Add .env.example to git (it's safe, contains no secrets):

   ```bash

   git add .env.example

```text

```python

```

6. Verify .env is in .gitignore (should be by default from create-next-app).

```html

  </action>
  <verify>

```markdown

1. Run `npm list zod` - should show installed version
2. Run `cat src/shared/lib/env.ts` - should show envSchema with Zod

validation

3. Run `cat .env.example` - should show all required env vars
4. Run `npx tsx -e "import { env } from './src/shared/lib/env';

console.log(env)"` - should print validated env vars

```html

  </verify>
  <done>

```html

Environment variables are validated with Zod at startup, .env.example
template exists for onboarding, and misconfigured environments fail fast
with clear error messages.

```html

  </done>
</task>

<task type="auto">
  <name>Task 3: Create Health Check Endpoint</name>
  <files>

```html

src/app/api/health/route.ts

```html

  </files>
  <action>

```
Create health check API endpoint (src/app/api/health/route.ts):

```typescript

import { prisma } from '@/shared/lib/db'
import { env } from '@/shared/lib/env'
import { NextResponse } from 'next/server'

export async function GET() {
  const checks = {

```yaml
timestamp: new Date().toISOString(),
status: 'ok' as 'ok' | 'error',
environment: env.NODE_ENV,
checks: {
  database: { status: 'pending' as 'ok' | 'error', message: '' },
  environment: { status: 'ok' as 'ok' | 'error', message: 'Validated' },
},

```yaml

  }

  // Check database connection
  try {

```yaml
await prisma.$queryRaw`SELECT 1`
checks.checks.database = { status: 'ok', message: 'Connected' }

```

  } catch (error) {

```yaml
checks.status = 'error'
checks.checks.database = {
  status: 'error',
  message: error instanceof Error ? error.message : 'Connection failed',
}

```javascript

  }

  const statusCode = checks.status === 'ok' ? 200 : 503

  return NextResponse.json(checks, { status: statusCode })
}

```yaml

This endpoint:

- Validates environment loaded correctly (Zod validation happens on import)
- Tests database connectivity with a simple query
- Returns structured health status for monitoring
- Uses proper HTTP status codes (200 OK, 503 Service Unavailable)

```html

  </action>
  <verify>

```yaml

1. Start dev server: `npm run dev`
2. Visit <http://localhost:3000/api/health> - should return JSON with status

"ok"

3. Expected response:

   ```json

   {

```
 "timestamp": "2026-01-24T...",
 "status": "ok",
 "environment": "development",
 "checks": {
   "database": { "status": "ok", "message": "Connected" },
   "environment": { "status": "ok", "message": "Validated" }
 }

```text

   }

```yaml

```yaml

```yaml

4. Run `curl <http://localhost:3000/api/health`> - should return same JSON

```html

  </verify>
  <done>

```text
Health check endpoint at /api/health returns database and environment
status, confirming the entire Phase 1 foundation is operational.

```

  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify the complete Phase 1 foundation:

1. **Database Connection:**

   ```bash
   npx prisma db push

   # Should succeed without errors

```yaml

2. **Environment Validation:**

   ```bash

   # Temporarily break .env to test validation

   echo "DATABASE_URL=invalid" > .env.test
   NODE_ENV=test npx tsx -e "import { env } from './src/shared/lib/env'" 2>&1 | head -5

   # Should show validation error, not crash silently

```yaml

3. **Health Check Endpoint:**

   ```bash
   npm run dev &
   sleep 3
   curl -s http://localhost:3000/api/health | jq .

   # Should return status: "ok" with all checks passing

```yaml

4. **Full Build:**

   ```bash
   npm run build

   # Should complete without TypeScript errors

```yaml

5. **Project Structure:**

   ```bash
   tree src/shared/lib/ -L 2

   # Should show:

   # src/shared/lib/

   # ├── db/

   # │   ├── index.ts

   # │   └── prisma.ts

   # └── env.ts

```html

</verification>

<success_criteria>

- Prisma ORM installed and configured for PostgreSQL
- Prisma singleton pattern prevents connection pool exhaustion
- Initial migration created and applied successfully
- Environment variables validated with Zod at startup
- .env.example template committed for team onboarding
- Health check endpoint returns database and environment status
- All TypeScript compilation succeeds
- Development server runs without errors

</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-setup/01-02-SUMMARY.md`
</output>
